# 同源策略
## 1.什么是同源策略
同源策略主要是浏览器为了保证用户信息安全而对js脚本做出的一种限制，跨域也是因为同源策略而造成的
+ 同源策略要求同协议、同域名、同端口
+ 同源策略规定当前域下面的js脚本不能访问其他域的cookie、localStorage、indexDB
+ 同源策略规定当前域下面的js脚本不能操作其他域下面的DOM
+ 同源策略规定当前域下面的ajax不能发起跨域请求
> `img`、`<script>`不会受跨域的限制，其原因是他们一般不会通过响应的结果去进行一些可能造成安全问题的操作
## 2.如何解决跨域
### CORS
CORS(跨域资源共享)是一种机制，他通过额外的HTTP头(体现在响应头)来使浏览器"**放行**"请求到的资源
> 因为CORS需要浏览器和服务端同时支持，而整个CORS过程都是浏览器自己完成的，不需要用户参与，所以人可以做的只在服务端了，所以我认为实现的关键在于响应头
CORS被分为**简单请求**和**非简单请求**
#### 简单请求
简单请求的条件有2个限制(请求的方法以及请求头):
- 请求方法：必须是HEAD、GET、POST三个之中的一个
- 请求头：必须在`Accept`、`Accept-Language`、`Content-Language`、`Last-Event-ID`、`Content-Type`这几个头信息的范围内
> Content-Type 只限于`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`,但是一般我们用**axios**发送post请求时，常用于对数据库产生一些副作用，所以会携带json数据，也就是说头`Content-Type`会自动配置`application/json`值,这也是尽管没怎么去配置HTTP头，但是预检请求也会发起的原因

简单请求不会发起预检请求，会在请求的头信息中增加一个`Orgin`字段，该字段用于描述发起请求的源，服务器会依照`Access-Control-Allow-Origin`字段的值来决定是否同意这次请求
+ 如果在许可范围内，服务器返回的响应中就会多出一些额外的信息头，例如`Access-Control-Allow-Origin`字段可以用来告诉浏览器是否放行，`Content-Type`描述返回的文档类型等等
+ 如果不在许可范围内，还是会返回一个正常的HTTP回应，但是浏览器没有发现上面的`Access-Control-Allow-Origin`头部信息，就不会放行，值得注意的是，这个返回的HTTP响应的状态码有可能是200.
所以在简单请求中，在服务器内，至少要设置`Access-Control-Allow-Origin`
#### 非简单请求
如果不满足上面的简单请求，那么就称之为非简单请求。
非简单请求的一大特点就是会发送预检(preflight)请求，在正式发送带有请求体的请求之前，浏览器会向服务端发送一次只包含头部信息的预检请求(options)，去询问服务端可以支持的自定义头、请求的方法等，如果不符合就不会请求，避免造成资源的浪费
+ 预见请求包含三个字段，其中关键字段是`Origin`表示请求的源，还包括`Access-Control-Request-Method`用来列出CORS请求会用到的HTTP方法，以及`Access-Control-Request-Headers`用来表示会额外发送的头信息(可以用于知晓是哪些头信息导致的预检请求)

服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断是否允许跨域请求，只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。在非简单请求中，至少需要设置以下字段`Access-Control-Allow-Origin`表示允许跨域的源地址、`Access-Control-Allow-Methods`表示服务器支持的所有跨域请求的方法、`Access-Control-Allow-Headers`表示服务器支持的所有头信息字段
> 对于附带身份凭证的请求(即服务器设置Access-Control-Allow-Credentials: true)，服务器不得设置 Access-Control-Allow-Origin 的值为"*"。否则请求将会失败。Cookie遵循同源策略，即使因为这个请求是跨域请求，但是每个Origin的Cookie是不能被其他Origin获取到的，也就是不允许Access-Control-Allow-Origin 的值为"*"

> 由于preflight请求属于cors规范的一部分，因此当前仅当跨域的情况下可能会触发preflight。也即：只有跨域了，且不满足之前触发条件中一条就会触发预检请求。没有跨域，不会触发预检请求。

#### 减少预检请求
可以在后端返回头中添加头部字段:"Access-Control-Max-Age",他的值是一个数字，单位是秒，表示预检请求可以被缓存多久，在这时间内再次发起请求就不会进行预检请求了，
> 这里想要说一下，在正式请求中设置是没有用的，得在中间件中配置才有用，例如`express`中在`app.all('*',()=>{/*这里设置才有用*/})`，而`app.post('/xxx',()=>{/*这里设置没用*/})`

### nginx代理跨域

#### 反向代理解决跨域

同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。

通过nginx配置一台代理服务器，作为跳板，然后反向代理到真实域中去，具体做法如下:(tips:亲测，自己验证了一下，没毛病)

>    使用 nginx的好处，个人感觉就是可以放松后端那边的一些限制，因为转发之后是同源之间进行数据请求，没有跨域的问题了，头信息对我们小白来说可以不用去花费心思去写很多

#### nginx配置

```nginx
# 验证之前 记得得在防火墙放行相关端口，别问我为啥要提醒(2个地方(服务器和宝塔)只放行了1个地方，导致死活验证不出来TAT)
# 假如服务器端口为8.217.49.181:4001
# 请求源随便啥域都行
# 现在如果直接请求就会跨域(端口肯定不同)
# 这时可以设置一个跳板端口，8.217.49.181:8081，通过监听8081端口的请求反向代理转发给后端端口
# 将我们请求的url设置为 "http://jialouluo.top:8081"
listen 8081; # 监听的端口--可以监听多个端口
server_name jialouluos.top; # 绑定一个域名
# 后端的路由匹配
location ~ ^/(api) {
      proxy_pass http://8.217.49.181:3000; # 反向代理
 }
```
#### 前端请求
```js
const request = axios.create({
    baseURL: "http://jialouluo.top:8081"
});
request({method: "get", url: "user/users",}).then( _ => {/**/});
```

### Nodejs中间件代理跨域

#### 非Vue框架的跨域

使用http-proxy-middleware包实现跨域，原理和nginx类似，都是绕过同源，通过启用一个代理服务器，实现转发

#### Vue框架

Vue脚手架自带跨域相关配置，我们只需要根据规则配置就行了，但是要注意，Vue所解决的跨域只能在开发环境中使用，生产环境是失效的

### JSONP

JSONP的原理就是利用`<script>`标签没有跨域的限制，通过src属性发送带有callback参数的get请求。服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。

缺点也很明显，不安全，容易遭受XSS攻击，仅支持get方法

### postMessage

一般用于：

-   页面和其打开的新窗口的数据传递
-   多窗口之间消息传递
-   页面与嵌套的iframe消息传递

### 还有一些暂时用不到的，比如iframe+window.name 、iframe+location.hash、iframe+document.domain、WebSocket.只作为了解，等用得到的时候在深入了解
