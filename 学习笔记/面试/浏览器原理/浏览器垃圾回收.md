# 浏览器垃圾回收

## V8垃圾回收机制

V8将内存分为了新生代和老生代两个部分，并且采用了不同的回收算法

### 新生代

任何对象的声明分配到的内存都会被先置放在新生代中，新生代的对象一般存活时间比较短，主要采用Scavenge 算法进行垃圾回收，这个算法是一个用空间换时间的算法，在新生代堆中非常适用

Scavenge算法将新生代堆分为了两个区，分别叫from-scape和to-scape，回收工作原理就是标记from中的活动对象和非活动对象，然后复制活动对象到to中去，接着释放from中非活动对象的内存，然后将from和to对调

>   值得注意的是，新生代中还进行了细分，首次分配内存会被分配到新生代的nursery子代，经过一次垃圾回收之后如果还存在则会移动到intermediate子代中去，如果再经过一次垃圾回收还存在就会被移动到老生代中去
>
>   另外如果To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。
>
>   **对象从新生代中移动到老生代中的过程称为晋升**

### 老生代

#### Mark-Sweep(标记清除)

>   如果采用新生代的GC算法，存在两个问题，老生代的对象一般都是至少经过了一次或多次回收的对象，他们存活的概率更大，这时候如果采用Scavenge算法，重复复制活动对象会使得效率变得低下，同时Scavenge算法是利用空间换时间的算法，在容量大的空间会出现空间浪费的情况

Mark-Sweep处理分为标记和清理阶段，其流程为

+   标记：对老生代进行第一次扫面，标记活动对象

+   清理：对老生代进行二次扫面，清除未被标记的对象(非活动对象)

>   这样处理会有一个问题，就是被清理的对象遍布各内存地址，会造成许多内存碎片，这时候就需要Mark-Compact来进行处理了

#### Mark-Compact(标记整理)算法

Mark-Compact是在Mark-Sweep的基础上演进而来的,相比于Mark-Sweep，Mark-Compact增加了活动对象整理阶段，将所有活动的对象往一段移动，移动完成之后，直接清理掉边界外的内存

但是涉及到了移动对象，所以速度不可能比Mark-Sweep快

所以在取舍上，V8主要使用Mark-Sweep，**在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact。**

## 回收优化

### 增量式标记回收

为了避免JavaScript应用逻辑和垃圾回收器的内存资源竞争导致的不一致性问题，垃圾回收器会将JavaScript应用暂停，这个过程，被称为全停顿

在新生代中，由于空间小、存活对象较少、Scavenge算法执行效率较快，所以全停顿的影响并不大。而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿。

为了降低全堆垃圾回收的停顿时间，增量标记将原本的标记全堆对象拆分为一个一个任务，让其穿插在JavaScript应用逻辑之间执行，**垃圾回收与应用逻辑交替执行直到标记阶段完成。**

###  懒性清理 

增量标记只是对活动对象和非活动对象进行标记，惰性清理用来真正的清理释放内存。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理的过程延迟一下，让JavaScript逻辑代码先执行，也无需一次性清理完所有非活动对象内存，垃圾回收器会按需逐一进行清理，直到所有的页都清理完毕。

### 并发

并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。减少了主线程的总暂停时间

### 并行

并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。

## 内存泄露

+   第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

+   第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

+   第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。

+   第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。
