# 进程与线程

## 1.进程与线程的概念

进程是对正在运行中的程序的一个抽象，进程是资源分配的基本单位，进程运行在虚拟内存上,虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。当一个进行关闭之后，操作系统会挥手进程所占用的内存，进程之间的内容相互隔离，如果想要进行进程之间的通信，则需要使用进程间的通信机制了

线程是调度的基本单位，一个进程至少拥有一个线程，可以拥有多个线程，线程共用进程的资源。进程中的任一线程执行出错，会导致整个进程崩溃

## 2.进程和线程的区别

+   一个进程可以看作一个独立的应用程序，而线程不能
+   一个进程可以包括多个线程
+   进程是cpu分配资源的最小单位，线程是cpu调度的最小执行单位
+   线程间可以共享同一进程中的资源，进程之间通信需要借助进程间的通信方式
+   进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
+   创建或销毁进程时，系统需要为其分配或回收资源，其开销大于创建或销毁线程时的开销

## 3.Chrome进程架构

+   浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
+   渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
+   GPU 进程：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
+   网络进程：主要负责页面的网络资源加载.
+   插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

## 4.浏览器渲染进程的线程有哪些

**（1）GUI渲染线程** 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要**重绘**或由于某种操作引发**回流**时，该线程就会执行。

注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

**（2）JS引擎线程** JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；

注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。

**（3）时间触发线程** **时间触发线程**属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；

注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；

**（4）定时器触发进程** **定时器触发进程**即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；

注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。

**（5）异步http请求线程**

-   XMLHttpRequest连接后通过浏览器新开一个线程请求；
-   检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；

## 5.进程之间的通信方式

+   管道通信，操作系统在内核开辟一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区中，进程2可以进行读取
+   消息队列通信，消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。但是数据块会受最大长度的限制
+   信号量通信，在进程占用某个资源时，将其信号量设置为占用状态，这样别的进程访问这个资源时就访问不了
+   共享内存通信，映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。
+   套接字通信(Socket)，其他几种都是用一台主机之间的进程进行通信，而套接字可以用于不同主机间的进程进行通信，比如发起http请求，然后服务器返回数据，这就是一种套接字通信

## 6.死锁产生的原因

+   竞争资源，比如进程1占用了某个资源，而进程2也要占用这个资源
+   进程间推进顺序非法，比如进程1占用了资源1，进程2占用了资源2，如果两个进程再往前推进，可能会出现进程2请求资源1，因为资源1已经被占用而导致阻塞，而进程1又请求资源2，资源2也被占用着，导致进程1也进入了阻塞，于是产生死锁

预防死锁：

+   资源一次性分配
+   只要有一个资源得不到分配，也不给这个进程分配其他的资源
+   可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源
+   资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反