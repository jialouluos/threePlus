# Vue基础

## 1.data为什么不是一个对象而是一个函数

在javaScript中对象是引用类型的数据，当多个实例同时引用一个对象的时候，只要一个实例对这个对象进行修改，则其他实例中这个对象的数据也会改变

而在Vue中，由于经常会有组件的复用，如果组件的data采用对象的方式去保存数据，如果某个组件对数据进行修改会导致所有相同组件的相关数据也发生修改。所以需要通过函数的方式去返回一个数据，这样每个复用组件都有属于自己的数据，组件之间也不会相互干扰。

## 2.谈谈你对nextTick的理解

由于Vue采用的是数据驱动页面的思想，所以我们只需要去关注数据的改变，vue会自动帮我们去进行页面的更新，但是Vue在更新DOM时是异步执行的，当数据发生改变时，会将所有修改数据的操作放入异步队列中，等同一事件循环中所有的数据变换完成之后再统一地去进行视图的更新。

>   如果我们一直修改相同数据，异步操作队列还会进行去重

如果想在DOM更新后立即拿到更新后的DOM数据，那么这时候就可以使用nextTick了，nextTick中的回调会在DOM更新之后被调用，以便于拿到最新的DOM数据

## 3.谈谈你对keep-alive的理解

keep-alive用于组件切换时，对旧组件的缓存，防止多次渲染，一般包裹在动态组件或者router-view

他有三个属性，include、exclude、max，include用于描述需要被缓存的组件名，exclude用于描述排除缓存的组件名，max描述最多可以缓存多少个组件

`keep-alive` 独有的生命周期，分别为 `activated` 和 `deactivated` 。用 `keep-alive` 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 `deactivated` 钩子函数，命中缓存渲染后会执行 `activated` 钩子函数。

## 4.双向数据绑定的原理 *

双向绑定就是当用户在视图层操作时，数据层也会及时的做出更新，数据层发生改变时，视图层也能够及时地体现出数据的更新

Vue采用数据劫持配合发布者-订阅者模式的方式来实现，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。

但是通过Object.defineProperty方式拦截的引用对象，无法监听到其深层次的变换，例如通过数组下标的方式修改数据，或者没通过Vue提供的增加属性API去增加新属性，这些都不能触发组件的重新渲染

## 5.Computed和Methods的区别

-   computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；
-   method 调用总会执行该函数。

## 6.Computed和Watch的区别

对于Computed：

+   计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值
+   不支持异步
+   如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值

对于Watch：

+   它不支持缓存，数据变化时，它就会触发相应的操作
+   支持异步监听
+   监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会执行相应的处理函数

## 7.v-if和v-show以及v-html的原理

v-if：它的编译条件是一种惰性的，如果为假，什么也不会做，在其身上挂载ref也无效，生成vnode的时候会忽略对应节点，render的时候也不会渲染，相较于v-show需要更高的切换消耗

v-show：他表现在css样式上，即display，初始为假也会编译然后被缓存，DOM元素保留，适合频繁切换

v-html：v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。

## 8.单页面应用与多页面应用的区别

-   SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。
-   MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。

## 9.React与Vue的区别

相同：

+   都将其他功能和路由都抽离出来交给相关的库，保持核心库的整洁干净
+   都有自己的构建工具(脚手架)
+   都使用了虚拟DOM
+   都用一些相似的概念props、组件

不同点：

+   Vue提倡双向数据绑定，React提倡单向数据流
+   React每次渲染都从根节点开始，Vue由于会跟踪每一个组件的依赖关系，可以实现部分渲染
+   Vue写法偏模板化、React写法JS化
+   Vue通过数据劫持实现监听数据变换，React通过比较引用
+   Vue采用双端算法diff,React采用遍历进行diff

## 10.MVVM、MVC、MVP的区别

### MVVM 

MVVM 分为 Model、View、ViewModel：

-   Model代表数据模型，数据和业务逻辑都在Model层中定义；
-   View代表UI视图，负责数据的展示；
-   ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；

Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。

### MVC

MVC 分为 Model、View、Controller ：

+   View 负责页面的显示逻辑
+   Model 负责存储页面的业务数据，以及对相应数据的操作。
+   Controller 负责用户与应用的响应操作

当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。

### MVP

MVP 分为 Model、View、Presenter ：

+   View 负责页面的显示逻辑
+   Model 负责存储页面的业务数据，以及对相应数据的操作。
+   Presenter 实现对 View 层和 Model 层的解耦

MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和Model 的解耦，Presenter 还包含了其他的响应逻辑。

## 11.SPA单页面的优缺点

优点：

+   SPA单页面对于用户说体验很快、内容的改变不需要重新加载整个页面，避免了多页面每次跳转都需要加载重复的css、js

+   采用单页面可以降低服务器的负载压力
+   前后端职责分明，前端负责交互逻辑、后端负责数据处理

缺点：

+   初次加载耗时长
+   SEO不好

## 12.对solt的理解

solt可以理解为一个坑位，当使用组件标签时，就会去占住这个坑位，插槽可以分为3类：

默认插槽：一个组件只能与一个默认插槽，当slot没有指定name属性值的时候一个默认显示插槽

具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。

作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。

当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在`vm.$slot`中，默认插槽为`vm.$slot.default`，具名插槽为`vm.$slot.xxx`，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用`$slot`中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。

## 13.Vue性能优化

对于编码阶段：

+   尽量减少`data`数据的层级和个数，因为每一个存在于data的数据都会进行数据劫持，会生成`getter`和`setter`
+   `v-if`和`v-for`不要连用
+   不要给`v-for`中的元素绑定事件，可以使用事件代理，绑定在他们共同的父节点上
+   更多的情况下使用`v-if`代替`v-show`，`v-if`是一种懒编译，如果为假，他就什么都不做，`v-show`如果为假他还是会加载相应资源，如果需要频繁变动，还是建议使用`v-show`，因为`v-if`相较于`v-show`需要更多的切换消耗
+   单页面可以采用keep-alive进行组件缓存
+   在v-for的时候，要保证key值的唯一性
+   使用路由懒加载、异步组件，这样可以大大减少首次加载的负荷
+   防抖节流
+   模块按需导入
+   图片懒加载
+   长列表滚动可视区域动态加载

对于SEO：

+   预渲染
+   服务端渲染

打包优化：

+   压缩代码
+   cdn加载第三方模块
+   (摇树优化)Tree Shaking/作用域提升(Scope Hoisting)
+   多线程打包
+   splitChunks抽离公共文件
+   sourceMap优化

用户体验：

+   开启缓存，客户端缓存、服务端缓存、gzip压缩

## 14.对SSR的理解

SSR表示服务端渲染，需要nodejs环境，服务端渲染是将HTML标签的组装放在服务端进行，组装完成之后，直接返回一整个html给客户端

SSR的优势：更好的SEO、首屏加载速度快

SSR的缺点：服务器负载需求更高、只支持部分生命钩子(created和beforeCreate)

## 15.Vue如何监听数组或对象某个属性的变化

如果是在项目中直接为某个对象新增一个属性的化，是不会经过数据劫持的，也就是说，当数据发生改变时，Vue是监测不到的，如果想要数据发生改变并且能够监听到，可以在组件的data里先初始化一下，或者调用`$set`,对于数组而言，Vue重写了能改变数组自身的7个方法，调用这7个方法，Vue也能够监听到数据发生变化

>   `splice()`、 `push()`、`pop()`、`shift()`、`unshift()`、`sort()`、`reverse()`

## 16.Vue生命周期

1.  **beforeCreate（创建前）**：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。

2.  **created（创建后）** ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染的节点还未挂载到 DOM，所以不能访问到 `$el` 属性。

3.  **beforeMount（挂载前）**：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。

4.  **mounted（挂载后）**：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。

5.  **beforeUpdate（更新前）**：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。

6.  **updated（更新后）** ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。

7.  **beforeDestroy（销毁前）**：实例销毁之前调用。这一步，实例仍然完全可用，`this` 仍能获取到实例。

8.  **destroyed（销毁后）**：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。

## 17.created与mounted区别

-   created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
-   mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

## 18.一般在哪个生命周期请求异步

在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。

推荐在**created**钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

-   能更快获取到服务端数据，减少页面加载时间，用户体验更好；
-   SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。

## 19.组件间的通信方式

父子间通信：

+   父向子：props，子向父：$emit,或者父组件下发一个函数给子组件，子组件可以利用这个函数间接控制父组件状态修改

+   $ref、\$parent
+   使用provide/inject

兄弟间通信：

+   创建一个全局事件总线(一个额外的空的Vue实例)来传递消息，通过在这个实例上进行监听和触发事件
+   $ref、\$parent

任意组件：

+   创建全局事件总线

额外：

+   Vuex 全局状态管理

## 20.hash与history的区别

hash会在URL带着一个#，hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。

history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。

## 21.params与query的区别

params:

+   传参只能使用路由的name，不能使用path
+   url中不带参数
+   刷新之后参数丢失

query:

+   传参可以通过路由的name，也可以通过path
+   url中会携带参数
+   刷新之后，参数还保留

## 22.对前端路由的理解

前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。

## 23.对Vuex的理解

Vuex是一个全局状态管理库，Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。他的核心是一个store，store是一个容器，用来保存我们应用中大部分的状态，如果想要改变store的状态是需要显式地调用相关API

## 24.Vuex中action与mutation的区别

mutation中的操作是一系列的同步函数，用于直接修改state中的变量的的状态。

Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，可以调用 context.commit 提交一个 mutation。

Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。

Mutation：必须同步执行；Action：可以异步，但不能直接操作State。

在视图更新时，先触发actions，actions再触发mutation

## 25.Redux与Vuex的区别

vuex借鉴了redux，改进了Redux中的一些核心函数，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;

本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案; 形式上：vuex借鉴了redux，将store作为全局的数据中心，进行model管理;

## 26.Vue3有什么更新

检测机制的变化：vue3.0采用Proxy配合Reflect去替换Object.defineProperty来实现响应式，原来采用defineProperty时需要遍历整个对象挨个添加getter、setter，现在Proxy可以直接劫持整个对象，并返回一个新对象，我们只需要操作新对象就可以实现响应式，最重要的一点是，V3的响应式消除了V2的一些响应式缺陷，比如数据下标数据变动缺少监听，为此不得不重写数组的几个操作方法，在v3这些都被解决了

拥抱Ts：V2如果与ts结合需要一些技术实现，而v3天然支持ts

组合式API：相比于v2的optionsAPI(选项API),V3采用了组合式API，

响应式：不通过data集中维护响应式数据了，使用ref和reactive来生成具有响应式的数据

根节点：V3可以存在多个根节点

增加了setup入口函数用来去替代beforeCreate和create，可以在入口函数里面使用组合式API了，返回值就和v2的data类似，模板中可以直接使用

## 27.defineProperty与proxy的区别

defineProperty时需要遍历整个对象挨个添加getter、setter，defineProperty检测不到对象属性的添加和删除，数组`API`方法无法监听到，需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题

Proxy可以直接劫持整个对象，并返回一个新对象，对这个对象的所有操作会进入监听操作，我们只需要操作新对象就可以实现响应式

## 28.Vue3的Composition API

Composition API是基于Vue的响应式系统实现的，相比于v2的optionsAPI(选项API),V3的组合式API提高了逻辑复用率，同时也使得项目逻辑分明，维护时能快速定位到相关部分的逻辑，声明在setup函数内，一次组件实例化只调用一次setup，Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用，响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成

## 29.对虚拟DOM的理解

虚拟DOM其实就是一个js对象，他存储着与其对应的dom节点的一些信息、和属性。然后再通过渲染，将虚拟DOM一次性转换为真实DOM，已达到减少页面渲染次数、减少回流和重绘，提高渲染的性能。

虚拟DOM也具有很好的跨平台性，在Nodejs环境下没有DOM的概念，但是存在虚拟DOM，这样就可以很好的实现SSR

在渲染完成后，也会缓存一份虚拟DOM的数据用户后续当数据发生改变重新渲染时做diff，去比较新老节点，加快渲染效率

## 30.diff算法

vue中的diff与react的diff不同，React中的diff时从头开始进行3次可连续的遍历，而Vue则采用的双端比较：

用4个分别指向新头、新尾、旧头、旧尾的指针，从两端向中间遍历收拢，每一次遍历新节点链前进一位(新头前进),然后判断是否与老链的旧尾旧头匹配，如果匹配则旧头前进或者旧尾后退，如果没有匹配则直接生成新节点，如果往复，直到遍历完成或者旧头大于旧尾，如果旧头的索引大于旧尾那么直接终止遍历，并把剩下未遍历的新链上的虚拟节点直接生成新真实节点

## 31.Vue中的key作用

key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速，同时也可以提高复用性

在v-for中注意尽量不要使用index作为key值，因为使用index 作为 key的时候，不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。
