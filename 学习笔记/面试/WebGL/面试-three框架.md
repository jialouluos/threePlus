## 1.在three.js中有几种光照

常用的一般下面几种:

环境光：笼罩在整个空间无处不在的光，在three中，它采用在物体光照信息基础上叠加上一个较小的光照常量，用来表示场景中其他物体反射的间接光照。

点光源：点光源可以理解为现实中的灯泡，他一般有四个参数第一个参数是光照颜色，第二个参数是光强，第三个参数是灯光的最大范围，第四个参数是衰减强度

聚光灯：聚光灯可以理解为现实中的手电筒，是一个圆锥形的光，有两个圆锥，内圆锥和外圆锥。光照强度在两个锥体之间从设定的强度递减到 0

平行光：平行光可以理解为现实中的太阳光，但是这个平行光是不会随着距离衰减的

还有半球光、矩形光等

## 2.模型重合相交部分闪烁解决办法？

这是一种深度冲突(z-fighting)现象,造成冲突的原因是两个三角面片靠的很近，在渲染时由于精度不够，所以难以分清谁在前面谁在后面

处理方法1：调整两个物体的坐标，让两个物体分开一些

处理方法2：调整camera的near和far值，我们知道在光栅化前会执行屏幕映射，其中透视除法会将裁剪空间转换到NDC空间，会归一化z值，z值的范围越大，就会导致归一化后的物体位置越靠近，更容易产生z-fighting现象

处理方法3：开启对数缓冲，但是他会使early-z的测试失效(early-z是一种优化手段，他允许在片元着色器执行之前进行深度测试，去避免一些看不到的片元被着色，提高程序性能)`renderer = new THREE.WebGLRenderer( { logarithmicDepthBuffer: true } )`

处理方法4：也可以开启网格材质中的polygonoffset(多边形偏移)，其原理是在渲染的时候，将模型的订单稍微向靠近或远离相机的方向做一定的偏移，从而错开两个靠近的面的目的。

## 3.threejs有哪些材质？

常用的材质一般有下面几个：

MeshBasicMaterial：该材质不受光照影响，是three里面最基本的材质之一

MeshLambertMaterial：一种非光泽表面的材质，具有漫反射，没有镜面高光。用于创建暗淡的、不光亮的物体。

MeshPhongMaterial：一种具有镜面高光的光泽表面的材质，该材质是基于Blinn-Phong反射模型，Blinn-Phong反射模型是基于Phong模型的优化，他将Phong模型中反射方向与人眼观察方向夹角替换成了一个半程向量和法线向量的夹角，这样得到的结果与真实计算反射与人眼观察夹角的结果是非常近似的(具体来说该角度是正确角度的一半)，但好处在于大大加速了角度计算的速度，提升了效率！[参考链接](https://zhuanlan.zhihu.com/p/144331612)

![img](https://raw.githubusercontent.com/jialouluos/pic/master/img/202209111731574.jpg)

MeshStandardMaterial：网格标准材质，一种基于物理的标准材质，它可以计算表面与光线的正确互动关系，从而使渲染出来的物体更加真实。

MeshPhysicalMaterial：网格物体材质，MeshStandardMaterial的扩展，能够更好地控制反射率。

ShaderMaterial：自定义着色器材质，直接控制顶点的放置方式和像素的着色方式。

其他的材质比如还有法向材质、网格深度材质、卡通材质等等

## 4.欧拉角了解吗？

欧拉角在three里面是一个用于描述旋转信息的对象，他由三个角组成，分别是x，y，z，每个角都对应在其对应方向旋转的角度。任意的旋转都可以由这三个角按照先后顺序旋转得到

## 5.渲染优化

对于渲染优化可以从模型，绘制，渲染执行，共享，销毁等几个方向来优化

+   模型：在建模软件(比blender)中可以去做一些减面、顶点融合、采用精简修改器、合并顶点、线、面、剔除隐藏面等来实现，同时还可以进行模型压缩，在建模时对于没必要展示的模型细节可以采用共享材质、加重顶点合并等去避免一些不重要的细节渲染，同时可以采用导出glb进一步减少模型大小,最后还可以进行模型切分，分块导入

+   渲染执行：可以通过按需渲染，来减少一些不必要的绘制，比如相机没动，那么就不执行render,相机变换再进行render，也可以设置一下每一帧的最大渲染次数。减少每帧渲染的频率

+   绘制：可以通过将多个不重要的几何体合并成一个几何体(Merge几何体)，还有一种Instance实例化几何体。下面来对比一下这两个方法的差别

    +   Instance：同一个Geometry ， 同一个 material ，但可以通过索引轻松控制每一个个体大小、位置等
    +   Merge：不同的 Geometry ，同一个 material 没有索引可以使用，合并后变为一个个体 ，难以单独控制

    |          | Instance实例化几何体 | Merge合并几何体 |
    | -------- | -------------------- | --------------- |
    | Material | 相同                 | 相同            |
    | Geometry | 相同                 | 不同            |
    | 单个控制 | 使用索引，轻松实现   | 难以实现        |
    | 生成时间 | 快速                 | 缓慢            |
    | 渲染性能 | 较优                 | 更优            |
    | 内存占用 | 极少                 | 较多            |
    | 绘制次数 | 1                    | 1               |

+   共享：对于一些不是特别重要的，但是还是需要保留一些细节的可以在程序中采取共用同一个材质节省内存

+   销毁：three不提供内存销毁管理，需要我们自己手动去调用dispose，所以一般的做法是自己封装一个销毁管理类，利用Set或者其他数据结构去遍历和储存场景中能够调用dispose的对象，在不需要运行时，统一集中进行销毁，同时也需要清空webgl上下文和解绑事件。内存的占用可以通过WebGLRender的info来查看

## 6.HDR和Tone Mapping是什么？

Tone Mapping叫色调映射，在查看高动态范围图像的时候经总是会遇到一个问题，CRT、LCD、打印机以及其它图像显示方法只能显示有限动态范围的图像。因此，人们开发了各种将高动态范围图像“转换”成可以查看的图像的方法(把HDR变成LDR)，这些方法统称为“色调映射”。three提供了几种，例如THREE.NoToneMapping、THREE.LinearToneMapping、THREE.ReinhardToneMapping、THREE.CineonToneMapping、THREE.ACESFilmicToneMapping目前大部分都在用

HDR指的是高动态范围成像，用来实现比普通数位图像技术更大曝光动态范围(即更大的明暗差别)的一组技术

## 7.什么是法线贴图？

法线贴图就是在原物体的凹凸表面的每个点上均作法线，通过RGB颜色通道来标记法线的方向,对于视觉效果而言，它的效率比原有的凹凸表面更高，若在特定位置上应用光源，可以让细节程度较低的表面生成高细节程度的精确光照方向和反射效果。

## 8.three中render之后做了什么

查看render源码可以发现，在调用render之后，会进行世界矩阵的更新，相机的更新，XR相关的一些更新，然后调用onRenderBefore生命周期，然后就开始初始化渲染相关的一些东西，通过两个全局变量数组renderStateStack和renderListStack和两个指针currentRenderList、currentRenderState去递归遍历场景进行物体的提取、分类。同时还存在着背景的渲染以及裁剪平面的初始化以及阴影、视口变换的处理，然后会将不同类型的物体(非透明、透射、透明)集合分别处理，对物体集合的物体挨个进行处理，处理的流程大致为将物体从世界空间转换到观察空间，处理材质双面绘制，利用叉乘判断逆顺时针绘制，提取场景中的相关属性，提取着色器所需要的一些属性，获取之前已经被处理的灯光信息传递给uniform，注册销毁事件、提取材质的unifrom信息，没有缓存的program就创建program，明确绘制的状态(比如说顺时针绘制还是逆时针，启不启用深度测试等等)，接着就去提取和处理顶点数据,这里会进行新旧数据对比，如果没变换则直接使用缓存，直接采用VAO的方式直接使用缓存的数据去作为后续绘制的数据，然后绘制所需的数据都准备完成之后，就根据绘制模型去进行绘制。绘制完成后会调用相关的生命周期以及处理一些后续清理工作
