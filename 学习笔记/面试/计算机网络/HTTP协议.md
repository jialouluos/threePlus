# HTTP协议

## 1.输入URL按下回车会发生什么

URL解析：

+   首先进行URL解析，分析使用的传输协议和请求资源路径，如果输入的URL不合法则会将地址栏输入的内容传递给搜索引擎，如果没有问题，则会检测URL中是否出现了非法字符，如果有就将其进行转义，之后便进行缓存判断

判断缓存：

+   如果所请求的资源在缓存中且没有失效，那么就直接使用，否则就发起新的请求,接下来会进行DNS解析

DNS解析：

+   DNS解析阶段主要是为了获取URL中的域名IP地址，首先会判断本地是否具有IP缓存，如果有则直接使用，否则会向本地DNS服务器发起请求，本地DNS服务器也会检查是否存在缓存，如果不存在则会向根域名服务器发起请求获取顶级域名服务器的地址，再向顶级域名服务器发起请求获取权威域名服务器地址，再向权威域名服务器发起请求获取IP地址，获取IP地址后将其返回给请求的用户

获取MAC地址：

+   当浏览器获取到IP地址之后，还会获取目的主机的MAC地址，这是因为应用层下发数据给传输层，TCP协议会指定源端口号和目的端口号，然后下发给网络层，网络层会将本机地址作为源地址，获取的IP地址作为目标地址，然后下发给数据链路层，数据链路层的发送需要加入双方的MAC地址，本机的MAC地址作为源MAC地址，目的MAC地址有两种情况，如果目的主机与源主机在同一个子网里面，可以使用APR协议直接获取到目的主机的MAC地址，如果不是，则需要转发给网关，让网关代为转发，此时也可以通过APR协议获取到MAC地址，此时的目的主机的MAC地址应该是网关的地址，接下来会建立链接即TCP的三次握手

建立连接：

+   三次握手完毕后，双方链接就建立了起来

+   如果使用的是HTTPS协议，在通信前还存在TLS的一个四次握手的过程。

    +   首先由客户端向服务端发送使用的协议的版本号、**一个随机数**和可以使用的加密方法。

        服务器收到之后，会确认加密的方法，同时也向客户端发送**一个随机数**和自己的数字证书。

        客户端收到后，首先检查数字证书是否有效，如果有效，则再生成**一个随机数**,并使用证书中的公钥对随机数进行加密，然后发送给服务器端，并且还会提供一个前面所有内容的hash值供服务端检验

        服务器接受之后使用自己的私钥对数据进行解密，同时向客户端发送一个前面所有内容的hash值供客户端进行检验。

        这个时候双方都有3各随机数，按照之前约定的加密方案，使用这三个随机数生成一把密钥，以后双方通信前就使用这个密钥对数据进行加密后再传输

发送请求：

+   建立了tcp连接之后，就可以在这基础上进行通信，浏览器发送http请求到目标服务器，请求的内容包括请求行，请求头，请求主体

返回数据:

+   当页面的请求发送到服务器端后，服务器端会返回一个html文件作为响应，浏览器接受到响应后，开始对html文件进行解析，开始页面的渲染过程

页面渲染：

+   浏览器首先会根据html文件构建一个DOM数，根据解析的CSS文件构建CSSOM数(CSS规则树)，如果遇到script标签，会判断是否含有defer或者async属性，要不然script的加载和执行会造成页面渲染的阻塞，当DOM树和CSSOM树建立完毕之后，则会根据他们来进行构建渲染树，渲染树构建好后，会根据渲染树去进行布局，布局完成会，使用浏览器的UI接口对页面进行绘制。页面就显示出来了

    ![1](./../z-img/ff9bb550bee845168a6895bfaa70a73b.png)

断开连接：

+   TCP四次挥手

## 2.GET和POST的区别

### 不同点

+   应用场景：GET请求一般用于不会对服务器产生影响的场景，比如请求一个网页，POST请求一般用于对服务器资源产生副作用的场景，比如注册用户

+   GET在浏览器回退时是无害的，而POST会再次提交请求。

+   是否缓存：浏览器一般会对GET请求缓存，很少对POST请求进行缓存

+   发送的报文格式：GET请求的报文实体部分为空，POST请求的报文实体部分一般为向服务器发送的数据

+   安全性：GET请求可以将请求的参数放入url中向服务器发送，POST请求一般不会将参数放在url中，这样不太安全，因为请求的参数会被保留在url中

+   请求长度：浏览器由于会对url长度进行限制，所以会影响get请求发送数据时的长度，这个长度是浏览器规定的，并不是RFC

+   参数类型：POST支持多种数据类型

+   数据包：对于GET请求会将http header和data一起发送出去，服务器响应200，而POST会先发送http header，服务器响应100，浏览器再发送data，服务器响应200，也就是说POST发送2次包，GET发送一次包，当然也有例外，火狐浏览器就只发送一次

###    相同点
+       用的都是同一个传输层协议，所以在传输上没有区别
+       报文参数的位置：只是一个约定，我们可以在`POST`请求中`url`中写入参数，或者`GET`请求中的`body`携带参数

## 3.PUT与POST的区别

+   PUT一般用于更新数据，他不会创建出新的数据种类--更新数据

+   POST一般可能会改变数据的种类--创建数据

## 4.常见的HTTP请求头

-   Accept:浏览器能够处理的内容类型
-   Accept-Charset:浏览器能够显示的字符集
-   Accept-Encoding：浏览器能够处理的压缩编码
-   Accept-Language：浏览器当前设置的语言
-   Cookie：当前页面设置的任何Cookie
-   Host：发出请求的页面所在的域
-   Referer：发出请求的页面的URL
-   User-Agent：浏览器的用户代理字符串

## 5.常见的HTTP响应头

-   Date：表示消息发送的时间，时间的描述格式由rfc822定义

-   server:服务器名称

-   Connection：浏览器与服务器之间连接的类型

-   Cache-Control：控制HTTP缓存

-   content-type:表示后面的文档属于什么MIME类型(常见的 Content-Type 属性值有以下四种)

    +   application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

    +   multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

    +   application/json：服务器消息主体是序列化后的 JSON 字符串。

    +   text/xml：该种方式主要用来提交 XML 格式的数据。

## 6.HTTP状态码304是多好还是少好

+   服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。

+   状态码304不应该认为是一种错误，而是对客户端**有缓存情况下**服务端的一种响应。

+   搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。

**产生较多304状态码的原因：**

-   页面更新周期长或不更新
-   纯静态页面或强制生成静态html

**304状态码出现过多会造成以下问题：**

-   网站快照停止；
-   收录减少；
-   权重下降。

## 7.常见的HTTP请求方法

-   GET: 向服务器获取数据；
-   POST：将实体提交到指定的资源，通常会造成服务器资源的修改；
-   PUT：上传文件，更新数据；
-   DELETE：删除服务器上的对象；
-   HEAD：获取报文首部，与GET相比，不返回报文主体部分；
-   OPTIONS：询问支持的请求方法，用来跨域请求；
-   CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；
-   TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。

## 8.HTTP1.0与HTTP1.1的区别

+   连接方面：http1.0采用非持久连接，如果想要启用持久连接需要自己在报文中添加启用字段，http1.1默认采用持久连接，持久连接主要是为了方便多个http请求复用同一个tcp连接，以此去避免每次请求需要建立连接的时延
+   资源请求方面：http1.0不能够只请求资源的某个部分，服务器会将整个资源全部发送过来，造成一定的带宽浪费，http1.1支持只请求资源的某个部分
+   缓存方面：http1.0主要在header中使用 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1引入了更多的缓存控制策略
+   http1.1新增了host字段用来指定服务器的域名
+   http1.1相比于http1.0增加了一些请求方法，比如PUT、OPTIONS、HEAD等

## 9.HTTP1.1与HTTP2.0的区别

+   二进制：http2.0 是一个二进制协议。在 http1.1版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。http2.0则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
+   多路复用:http2.0实现了多路复用，仍采用tcp连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞(如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。)"的问题。
+   数据流：http2的数据包不是按顺序发送的，同一个连接连续的数据包，可能属于不同的请求，所以需要对数据包进行标记，标明它是属于哪一个请求，http2将一个请求的所有数据包称为一个数据流，每个数据流都有唯一的ID，数据包发送时需要标记数据流ID用来区分他是哪个数据流
+   头信息压缩：http2使用了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
+   服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

##  10.HTTP和HTTPS协议的区别

HTTP和HTTPS协议的主要区别如下：

-   HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；
-   HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；
-   使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；
-   HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。

## 11.三次握手与四次挥手

3次握手：

![img](https://static.developers.pub/7775169b6f2646238669a18ff3d38374.png)

+   第一次握手：客户端向服务器发送一个SYN报文，并进入SYN_SEND状态等待服务器的确认

+   第二次握手：服务器收到客户端的SYN报文，需要给客户端发送一个ACK确认报文，并且还需要发送一个SYN报文，然后服务器进入SYN_RCVD状态，服务器会将该状态下的请求放入一个半连接队列

+   第三次握手：客户端收到服务器的SYN、ACK报文，向服务器发送确认包，客户端进入ESTABLISHED状态，服务器送到确认包也会进入ESTABLISHED状态，这是客户端和服务器就建立了链接

4次挥手:

+   第一次挥手：客户端发送FIN包，客户端进入FIN_WAIT_1状态，此时服务端仍然可以发送数据给客户端

+   第二次挥手：服务端收到FIN包，发出确认包ACK。服务器进入CLOSE_WAIT状态，这个时候客户端已经没有数据要发送了，服务器如果还有数据发送的话，客户端依旧要接受。客户端接受到服务器发送的ACK包后进入FIN_WAIT_2状态

+   第三次挥手：服务器数据发送完毕之后，会向客户端发送FIN包，服务器此时进入LAST_ACK状态

+   第四次挥手：客户端接受到服务器发送的ACK包后，会发生确认包，此时客户端就进入TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。服务器接受到确认包后进入CLOSED状态，客户端等待了某个固定时间之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接进入 `CLOSED` 状态。

## 12.keep-alive

在HTTP1.0中每次建立一个连接完成请求或应答后就会立即断开连接，这就是短连接，而在keep-alive模式下可以保持一种长连接的状态，能够保证客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，keep-alive功能就会避免重新去建立连接，这就是长连接，在http1.0下keep-alive模式默认是不启用的，需要手动在请求报文中添加启用字段才可以，而在HTTP1.1时规定了默认保持长连接

优点：

+   减少了后续请求的延迟（⽆需再进⾏握⼿）
+   降低拥塞控制 （TCP连接减少了）
+   较少的CPU和内存的使⽤（由于同时打开的连接的减少了）

缺点：

+   长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。

## 13.HTTP请求的报文是什么样的

请求报文由4部分组成：请求行、请求头部、空行、请求体

+   请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 
+   请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔
+   请求体: post put等请求携带的数据

##  14.HTTP响应报文的是什么样的？

请求报⽂有4部分组成:

-   响应⾏ 由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。
-   响应头 响应部⾸组成
-   空⾏
-   响应体 服务器响应的数据

## 15.如何理解CDN

CDN即内容分发网络，通俗理解就是根据用户位置分配最近的资源。

用户在上网的时候不用访问源站，而是访问离他最近的一个CDN边缘节点，在应用CDN后，DNS返回的不是一个IP地址，而是一个别名记录，该别名记录指向CDN的全局负载均衡

由于没有返回IP地址，所以本地的DNS服务器会再向负载均衡系统发起请求，CND的全局负载均衡系统会进行智能调度，去通过用户IP地址，找到相对最近的边缘节点，同时根据节点的负载情况，将最合适的节点返回给用户，用户就可以就近访问CDN的缓存代理了

缓存代理会有选择的缓存那些最常用的资源，如果用户访问的资源恰好在缓存系统里，可以直接返回给用户，没有的话就只有回源站取

作用：

+   提高了访问速度
+   降低了传输延迟，实现了网站加速

## 16.DNS协议是什么

DNS通俗来讲就是将域名翻译为IP，通过以迭代查询的方式向根域名、顶级域名、权威域名服务器发送请求从而获得IP并返回，同时也会将获取的IP进行缓存，便于后续直接复用

查询步骤：

首先浏览器请求资源，如果请求的资源没有缓存就会发起新的请求，接着进行域名解析，

首先搜索浏览器的DNS缓存

如果没有命中，就搜索操作系统的DNS缓存

如果还是没有命中则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果。

若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询。

本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来

操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起

至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

## 17.为什么说HTTPS比HTTP安全

对于http协议，通信时采用明文传输，内容很有可能被窃听，同时他也不会验证通信方的身份，因此有可能遭遇伪装，而HTTPS采用加密传输，同时其安全性也有SSL来保证

https在通信的过程中的**机密性**采用对称加密和非对称加密，也就是混合加密，通过采用非对称加密解决秘钥交换的问题，具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”

通过摘要算法生成数字签名保证**完整性**，同时引入第三方机构，比如CA，来确保公开密钥的安全性以及进行**身份认证**

## 18.OSI七层模型

第七层：应用层：该层定义了应用进程之间的交互规则，通过不同的协议为不同的应用

第六层：表示层：主要包括数据压缩，数据加密以及数据描述

第五层：会话层：负责建立、管理和终止表示层实体之间的通信会话

第四层：传输层：为两个主机之间的进程的通信提供服务

第三层：网络层：为数据的传输选择合适的网络路由和交换节点，保证数据准时安全的传输

第二层：数据链路：将上层的IP数据报组装为帧，在两个相邻的节点之间传递

第一层：物理层：实现在相邻节点以比特流进行透明传送，并确定一些传输媒体的物理接口的特性

## 19.TCP与UDP区别

UDP是一个面向数据报的无连接的通信协议，对于应用层下发的报文采取不合并不拆分，只是在其上面加上首部就交给下面的网络层，其传输效率高，但是不安全和准确，并且如果丢包，UDP不会重发。适用于直播，实时会议等

TCP是一个面向字节流的有连接的传输协议，对于上层下发的报文数据分解为多个TCP报文段进行传输，在目的站重新装配，其传输效率比UDP低，但是更安全更准确，如果丢包，TCP会重新发送，适用于文件传输，要求可靠传输的应用

无连接是指数据传输前后不连接，发送端只负责将数据发送到网络，接收端从消息队列读取

有连接是指建立连接3次握手、断开连接四次挥手

## 20.WebSocket

WebSocket，是一种网络传输协议，位于`OSI`模型的应用层。可在单个`TCP`连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅，客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输，一般用于弹幕、媒体聊天、协同编辑等

## 21.session 与 token的区别

seesion的原理是浏览器访问服务器，然后服务器会创建一个该浏览器的session，然后会把sessionID返回给浏览器客户端，浏览器下次访问就会带着这个sessionID来进行访问

token的原理就是浏览器访问服务器，服务器生成一个密钥，并返回一个加密的Token给浏览器，浏览器拿着token去访问服务器，服务器根据这个密钥去验证token，返回数据
