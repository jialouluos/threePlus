# JS异步

## 一.异步和同步的概念

+   **同步**：在执行某段代码时，如果没有得到返回结果，则剩下的代码是无法继续执行的，只有等到当前代码执行完毕拿到返回结果时，才能够继续执行下去。即同步会阻塞代码执行。

    +   JS属于单线程，任何时候都只能做一件事！同步任务在主线程中执行。

       +   Q:为什么JS选择单线程呢？A:JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。
       +   Q:JS如果是单线程，那怎么能进行异步操作呢？A:遇到异步事件，浏览器另开一个线程，主线程继续执行.HTML5提出了Web Worker标准，允许创建多个线程，但是子线程会受到主线程的控制，所以并没有改变js单线程的本质
    
    +   如果在函数返回结果的时候，调用者能够拿到预期的结果(就是函数计算的结果)，那么这个函数就是同步
    
       ```js
       //alert(),如果用户不去点击alert,网页的渲染便会暂停。代码的执行也会受到阻塞
       const syncFunc=(a, b)=>{
           return a + b;
       }
       let result = syncFunc(10,20);
       alert("我正在阻塞后面内容的执行...")
       console.log(result);
       ```
       
        ```js
        //console.log(result)也得等syncFunc函数执行完毕拿到返回结果才能够开始执行
        const syncFunc=(a, b)=>{
            return a + b;
        }
        let result = syncFunc(10,20);
        console.log(result);
        ```
       
    +   如果函数是同步的，尽管执行时间比较长，后面的代码也会等到该函数执行完之后再执行
    
        ```js
        const syncFunc=(a, b)=>{
            let time = new Date().getTime();
            while(new Date().getTime() - time >3000){}
            return a + b;
        }
        let result = syncFunc(10,20);
        console.log(result);
        ```
    
    +   异步操作也可以被同步化==>async/await语法糖
    
        ```js
        //是否被同步化可以打印输出的顺序，如果未被同步化 打印结果为一个Promise实例和2，如果同步化打印'返回的消息'和2;
        //可以删掉await关键字查看两者的结果
        const Func = () => new Promise((res, rej) => {
            setTimeout(() => {
                let result = "我是被返回的消息";
                res(result);
            }, 1000)
        })
        const asyncFunc = async () => {
            let result = await Func();
            console.log(result)
            console.log(2)
        }
        asyncFunc();
        
        ```
    
+   **异步**：在执行某段代码时，如果没有得到期望返回的结果时，剩下的代码还是会继续执行，并且会在后面的某一个时刻拿到这个预期结果。一般通过回调函数处理这个调用之后拿到结果。即异步不会影响阻塞后面的代码执行。

    +   压入(写入)Event Queue(事件队列or任务队列)，异步任务不会在该队列执行。
    
    +   主线程完成所有任务就去查看事件队列，如果存在任务就结束等待状态，进入执行栈，开始执行。主线程不断重复这一步。运行机制又称为Event Loop（事件循环）。
    
        +   压入的就是整个异步操作吗？A:压入的是异步操作的回调，比如说onclick 当事件触发的时候，回调函数会立即添加到任务队列中。setTimeout 当时间到达的时候(在此之前会存在于异步模块中)，才会将回调函数添加到任务队列中。一些网络请求会在请求完成返回之后，才将回调添加到任务队列中。
        +   Q:是指的是一个函数调用完，就去查看事件队列存在几个异步吗?A:不是单指一个函数，是指的全部的同步任务，即主线程没有任务之后
        +   Q:主线程以怎样的形式去查看事件队列呢？A:主线程主动去查看，排在前面的事件，优先被主线程读取。（也有一种说法是通知主线程，这两种说法主动和被动不一致，这里蹲一下后续更加权威的说法）
        +   Q:排在前面的一定比排在后面的先被主线程读取吗？A:如果是定时器，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能将回调添加进任务队列，从而返回主线程执行。
    
    +   遇到异步事件，浏览器另开一个线程，主线程继续执行，待结果返回后，执行回调函数。
    
    +   微任务与宏任务：任务队列分为宏任务`macro-task`和微任务`micro-task`在最新的标准，他们又被称为`task`和`job`
    
        +   `macro-task（宏任务）`大概包括：`script(整体代码)`,`DOM(onclick、onscroll)`,`ajax` ,`setTimeout`, `setInterval`, `setImmediate（NodeJs）`, `I/O`, `UI rendering`(也是排序顺序)
        +   micro-task（微任务）大概包括: `process.nextTick(NodeJs)`, `Promise`, `Object.observe(已废弃)`, `MutationObserver(html5新特性)`(也是排序顺序)
        +   来自不同任务源的任务会进入到不同的任务队列。其中 `setTimeout` 与 `setInterval` 是同源的
        +   事件循环决定了代码的执行顺序，从全局上下文进入函数调用栈开始，直到调用栈(主线程)清空，然后执行所有的`micro-task（微任务）`，当所有的`micro-task（微任务）`执行完毕之后，再取出执行`macro-task（宏任务）`，其中一个`macro-task（宏任务）`执行完毕，再次执行所有的`micro-task（微任务）`，一直循环直至执行完毕。
        +   JavaScript 引擎首先从宏任务队列中取出第一个任务；
        +   执行完毕后，再将微任务中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行，**也就是说在执行微任务过程中产生的新的微任务并不会推迟到下一个循环中执行，而是在当前的循环中继续执行。**
        +   然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。
        +   **一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务。**
        +   [宏任务与微任务1(参考链接)](https://juejin.cn/post/6844903692752142343#heading-5)
        +   [宏任务与微任务2(参考链接)](https://juejin.cn/post/6992167223523541023)
        
        ```js
        //一个最简单的异步，异步常见有四种 事件监听 定时器 网络请求 一些文件的读取
        const asyncAdd=(a,b)=>{
            console.log(a+b);
        }
        setTimeout(asyncAdd(1, 2), 8000);
        ```

## 二.Promise

+   解决出现多层回调的问题(回调地狱)

+   解决难以处理回调错误的问题

+   三大状态

    +   pending 表示进行中，Promise实例创建后的初始态
    +   fulfilled 表示成功完成，在执行器中调用resolve后达成的状态
    +   rejected 表示操作失败，在执行器中调用reject后达成的状态

+   两个过程

    +   pending -> fulfilled : Resolved(已完成)
    +   pending -> rejected : Rejected(已拒绝)

+   一旦状态改变就不会再改变

+   Promise 实例创建后，执行器里的逻辑会立刻执行，在执行的过程中，根据异步返回的结果，决定如何使用 resolve 或 reject 来改变 Promise实例的状态。

    ```js
    (async value =>
     new Promise((res, rej) => {
        console.log("我将被立即执行");
        value && res("我是pading=>fulfilled");
        rej("我是pading=>rejected")
    }).then(res => {
        console.log(res)
    }).catch(error => {//这里(catch函数)可以省略
        console.log(error);
    })
    )(1)
    ```

+   promise 使用 `回调函数延迟绑定`、`返回值穿透`、`错误冒泡` 来解决回调地狱的问题

    +   回调延迟绑定 体现在Promise的回调函数不是直接声明的，而是通过后面的 then 方法传入的，即延迟传入，这就是回调函数延迟绑定。

    +   返回值穿透  根据 then 中回调函数的传入值创建不同类型的 Promise，然后把返回的 Promise 穿透到外层，以供后续的调用。

    +   错误冒泡 前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了。

        ```js
        const MyPromsie = async (value,layer) => new Promise((res, rej) => {
            console.log("我被执行了",layer)
            value && res("我是pading=>fulfilled");
            rej("我是pading=>rejected layer=" + layer);
        })
        MyPromsie(2,0).
        then(res => MyPromsie(1,1)).
        then(res => MyPromsie(1,2)).
        then(res => MyPromsie(0,3)).
        then(res => MyPromsie(1,4)).
        catch(error => console.log(error))
        //打印结果：
        //我被执行了 0
        // 我被执行了 1
        // 我被执行了 2
        // 我被执行了 3
        // 我是pading=>rejected layer=3
        ```

+   方法：

    +   then() `then`方法返回的是一个新的Promise实例。因此可以采用**链式写法**，即`then`方法后面再调用另一个then方法

    +   catch() catch方法相当于`then`方法的第二个参数，指向`reject`的回调函数。 在执行`resolve`回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入`catch`方法中
    
    +   all() 方法可以完成**并行任务**， 它接收一个数组，数组的每一项都是一个`promise`对象。当数组中所有的`promise`的状态都达到`resolved`时，`all`方法的状态就会变成`resolved`，如果有一个状态变成了`rejected`，那么`all`方法的状态就会变成`rejected`调用`all`方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象`resolve`执行时的值。
    
        ```js
        let delayFunc1 = new Promise((res,rej)=>{
            setTimeout(()=>{res(1)},1000);
        })
        let delayFunc2 = new Promise((res,rej)=>{
            setTimeout(()=>{res(2)},2000);
        })
        let delayFunc3 = new Promise((res,rej)=>{
            setTimeout(()=>{res(3)},3000);
        })
        Promise.all([delayFunc1,delayFunc2,delayFunc3]).then(res=>{
            console.log(res);//结果为：[1,2,3] 
        })
        ```
    
    +   rece()  `race`方法和`all`一样，接受的参数是一个每项都是`promise`的数组，但与`all`不同的是，当最先执行完的事件执行完之后，就直接返回该`promise`对象的值。如果第一个`promise`对象状态变成`resolved`，那自身的状态变成了`resolved`；反之，第一个`promise`变成`rejected`，那自身状态就会变成`rejected`。当需要执行一个任务，超过多长时间就不做了，就可以用这个方法来解决：
    
        ```js
        Promise.race([promise1, timeOutPromise(5000)]).then(res => console.log(res))
        ```
    
    +   finally()  方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。在执行完`then`或`catch`指定的回调函数以后，都会执行`finally`方法指定的回调函数。
    
        ```js
        server.listen(port)
            .then(function () {
            // ...
        }).finally(server.stop);
        ```
    
    +   allSettled() 语法及参数跟 Promise.all 类似，其参数接受一个 Promise 的数组，返回一个新的 Promise。唯一的不同在于，执行完之后不会失败，也就是说当 Promise.allSettled 全部处理完成后，我们可以拿到每个 Promise 的状态，而不管其是否处理成功。
    
    +   any() 只要参数 Promise 实例有一个变成 fullfilled 状态，最后 any 返回的实例就会变成 fullfilled 状态；如果所有参数 Promise 实例都变成 rejected 状态，包装实例就会变成 rejected 状态。

## 三.Async/Await

+   概念

    +   代表异步JS编程范式的迁移。他改进了生成器(generator)的缺点，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力。

    +   其实 async/await 是 Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。

    +   async 用来声明异步函数，这个关键字可以用在函数声明、函数表达式、箭头函数和方法上。

    +   await关键字可以暂停异步代码的执行，等待Promise解决。

    +   async 关键字可以让函数具有异步特征，但总体上代码仍然是同步求值的。

+   **await**在等啥

    +   如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的内容；

    +   如果它等到的是一个 Promise 对象，await 就就会阻塞后面的代码，等着 Promise 对象 resolve，然后将得到的值作为 await 表达式的运算结果。

        ```js
        function testAsy(x){
            return new Promise(resolve=>{
                setTimeout(() => {
                    resolve(x);
                }, 3000)})}
        async function testAwt(){    
            let result =  await testAsy('hello world');
            console.log(result);    // 3秒钟之后出现hello world
            console.log('cuger')   // 3秒钟之后出现cug
        }
        testAwt();
        console.log('cug')  //立即输出cug
        ```

        +   async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以'cug''最先输出，hello world'和 cuger 是3秒钟后同时出现的。

+   优势

    +   代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的理解负担；
    +   Promise传递中间值很麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅；
    +   错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获比较冗余；
    +   调试友好，Promise的调试很差，由于没有代码块，不能在⼀个返回表达式的箭头函数中设置断点，如果在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。

+   异常处理

+   这里定义一个异步方法 run，由于 await 后面需要直接跟 Promise 对象，因此通过额外的一个方法调用符号 () 把原有的 exe 方法内部的 Thunk 包装拆掉，即执行 exe(false)() 或 exe(true)() 返回的就是 Promise 对象。在 try 块之后，使用 catch 来捕捉,这个 false 就是 exe 方法对入参的输出，而这个 no 就是 setTimeout 方法 reject 的回调返回，它通过异常捕获并最终在 catch 块中输出。

    ```js
    const exe = (flag) => () => new Promise((resolve, reject) => {
        console.log(flag);
        setTimeout(() => {
            flag ? resolve("yes") : reject("no");
        }, 1000);
    });
    const run = async () => {
        try {
            await exe(false)();
            await exe(true)();
        } catch (e) {
            console.log(e);
        }
    }
    run();
    //false
    //no
    ```

#### 参考链接

[万字长文，重学JavaScript异步编程](https://juejin.cn/post/6995357238277701668#heading-32)

[JavaScript 同步和异步(执行机制)](https://juejin.cn/post/6844903855084290056#heading-0)

[JavaScript 事件循环及异步原理](https://juejin.cn/post/6844903692752142343)

[异步JavaScript简介](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing#%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9C%AC%E8%B4%A8)

[JavaScript 运行机制详解：再谈Event Loop](https://www.ruanyifeng.com/blog/2014/10/event-loop.html)
