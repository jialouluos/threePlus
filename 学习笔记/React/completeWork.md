# completeWork

`completeWork`发生在`beginWork`阶段完成之后，经过`Diff`处理的`fiber`的形态已经确定了，该打的flag也已经被打上了。但是对于原生DOM组件和文本组件来说，虽然他们的`fiber`已经确定了，但是他们对应的DOM节点(`fiber.stateNode`)还没有发生改变，所以`completeWork`阶段需要去构建和更新一下原生DOM组件和文本组件的DOM节点以及自下而上收集`effectList`

对于不具有DOM节点的`fiber`，需要先创建他的DOM(注意只是创建，并不会挂载到页面上去),然后再通过节点插入算法去实现节点的插入，大致原理就是，创建一个新的DOM节点，并将其子节点插入进来，对于子节点来说它会优先检查自身，如果自身不是原生DOM组件，那么就继续往下找直到找到第一个原生DOM组件或null，找到之后，就会去看这一层(找到原生组件的那一层)是否还存在同级的兄弟节点，如果存在的话会重复一遍查找的流程。如果原生DOM组件存在DOM节点，则直接进行插入即可

在构建完DOM树之后，便会进行属性的创建和更新，对于刚创建的DOM节点，会进行属性的创建(利用props),事件绑定也发生在此时，对于原本就存在的DOM节点，会进行`Propsdiff`比较前后`props`是否存在不同，如果存在不同就会将经过`Propsdiff`比较的结果挂载到原生组件的`updateQueue`中，一旦节点的`updateQueue`不为空，它就会被标记上Update的`effectTag`

对于收集`effectlist`，其原理就是每一个非原生DOM组件对应的fiber节点都有一个由`fristEffect`和`lastEffect`构成的链表去记录着该fiber所有的`effectTag`,自下而上的`completeWork`的过程中也会自下而上的去收集effect链，最终收集到root中，自此就完成了`effectList`的收集，对于收集的原理就是，先将本身的`effectList`并入父级，再判断他自己有没有`effectTag`，这里先收集子节点再收集兄弟节点，如果有就将他插入到最后。

对于错误边界，如果在构建fiber时出现了错误，由于concurrent模式下使用try...catch方式包裹了执行函数，这样如果发生了错误就会被捕获到从而执行handleError，该函数主要获取出错的节点并且内部调用throwException去将这个出错的节点打上Incomplete 的effectTag，然后在向上找到可以处理错误的节点（即错误边界），添加上ShouldCapture 的 effectTag。最后创建一个表示错误的update，然后将getDerivedStateFromError`放入payload，`componentDidCatch`放入callback。最后将这个update放入错误边界的updateQueue。这些做好之后就会回到错误的节点执行completeUnitOfWork去终止该节点和后续节点的后续操作，在completeUnitOfWork中由于有Incomplete标记，所以会走另一条道路unwindWork，该函数用于判断当前节点是否是错误边界，会将当前节点的父节点也标记上Incomplete，这样在父节点执行unwindWork时也能够被执行unwindWork，进而验证它是否是错误边界，同时还会清空父节点上的effect链。而验证的关键就是当前节点是否存在ShouldCapture，如果不存在，则继续往上查找，重复步骤，如果存在就会被return出去，并将ShouldCapture标记删除，重新打上DidCapture标记，并将该节点赋值给workInProgress以便于重新beginWork去执行备用UI渲染，然后在beginWork阶段代表错误的update就会被执行，从而得到新的state，在beginWork的finishClassComponent函数中如果判断组件有DidCapture，会卸载掉它所有的子节点，然后重新渲染新的子节点，这些子节点有可能是经过错误处理渲染的备用UI。这样备用的UI就得以展示

## 总结

completeWork阶段主要负责原生DOM组件的真实DOM(stateNode)创建以及更新，真实DOM(stateNode)属性的创建和更新，effectList的收集，以及错误边界的处理