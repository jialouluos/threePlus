# commit阶段

## R17以前

在经过render阶段之后，WIP树上的fiber已经是最新的状态了，这时就可以进入commit阶段通过去循环effectList链表实现将有更新的fiber应用到页面上来了(不会循环整棵树),对于commit来说他的入口函数是`commitRoot`,他会告知给调度以立即执行的优先度去调度commit阶段的工作

commit阶段的工作可以分为3个阶段：before mutation、mutation、layout。

在before mutation阶段针对函数组件会发起一次useEffect异步调度，同时在beforeMutation调度之前需要执行一遍上一次的useEffect以确保本次调度的Effect都是本次更新产生的。针对类式组件会调用生命周期`getSnapshotBeforeUpdate`去获取一个在更新之前的快照。

在mutation阶段会进行相关的DOM操作，这时会用到节点操作的相关算法，例如节点新增算法、节点删除算法、节点更新算法，针对类组件来说还会调用生命周期`componentWillUnmount`读取组件的状态，在组件销毁前最后去保存组件的状态信息，针对函数组件，就会去执行useLayoutEffect的销毁函数，同时在mutation阶段结束后，layout阶段开始前会进行WIP树与current树的切换。

在layout阶段会读取组件的最新状态，对于类式组件会调用生命周期`componentDidMount`和`componentDidUpdate`，调用setState的回调，对于函数组件会填充useEffect 的 effect执行数组，并调度useEffect，另外会采用两个数组分别存储create和destroy，在页面被渲染完成之后再去执行，执行是先执行上一次的销毁，再执行这一次的创建。

值得注意的是，在before mutation阶段发起的异步调度useEffecf和这里发起的useEffect调度是互斥的，只会发起一次调度。

useLayoutEffect在执行的时候，也是先销毁，再创建。和useEffect不同的是这两者都是同步执行的，前者在mutation阶段执行，后者在layout阶段执行。与useEffect不同的是，它不用数组去存储销毁和创建函数，而是直接操作fiber.updateQueue。

-   useInsertionEffect 是在 mutation 阶段执行的，虽然 mutation 是更新 DOM ，但是 useInsertionEffect 是在更新 DOM 之前 。
-   useLayoutEffect 是在 layout 阶段执行，此时 DOM 已经更新了。
-   useEffect 是在浏览器绘制之后，异步执行的。

useEffect不会阻塞渲染，而useLayoutEffect会阻塞渲染。

## R17以后

在R18中放弃了以循环effectList链的方式去进行更新，而是采用类似于begin-complete的方式去进行更新，通过rootFiber自上而下的去调和进行处理和更新

before mutation阶段，会先执行`commitBeforeMutationEffects_begin`向下找寻最底层具有`Before Mutation`标志的fiber，通过nextEffect指向当前的fiber，找到之后就开始执行`commitBeforeMutationEffects_complete`去**真正**处理`before mutation`阶段需要处理的事情，再向上归并，在向上归并的过程中(不会执行begin，只会执行complete)，会先处理兄弟节点上的 Before Mutation，如果没有兄弟节点，那么返回父级节点，继续进行如上流程。这个和render阶段的begin-complete非常像

mutation阶段 这里的调和原理和before mutation一样，也是begin-complete的方式去处理，当然除了执行complete之外还会调用`commitDeletion`去执行元素删除操作（`fiber.deletions!==null`），如果是真实节点那么就会**删除真实 DOM 节点** ，如果是其他类型的fiber，则会 调用commitUnmount 方法。commitUnmount 对于函数组件来说会调用useInsertionEffect 和 useLayoutEffect 销毁函数 destroy，对于类式组件来说会置空Ref和调用生命周期`componentWillUnmount`,该阶段的complete处理顺序和之前一样，主要作用就是调用`commitMutationEffectsOnFiber`,该函数会依据不同的Tag进行不同的处理，节点插入也在此时，如果有兄弟节点，那么在调用 insertBefore 往兄弟节点之前插入就可以了。如果没有之后的兄弟节点，说明需要插入最后一个子节点，那么调用 appendChild 插入节点就可以了。然后执行useInsertionEffect，然后更新文本节点，更新元素节点。

layout阶段 到了这一个阶段，DOM都已经被更新完毕了，这时就可以获取更新之后的DOM了，Layout也会进行begin-complete，begin和mutation阶段差不多，complete阶段有一个重要的函数`commitLayoutEffectOnFiber`首先对于函数组件，执行 useLayoutEffect。对于类组件，如果初始化会执行 componentDidMount，如果更新会执行 componentDidUpdate。如果类组件触发 setState 并且有第二个参数 callback，那么这些 callback 会被放进 updateQueue 中，那么接下来会通过 commitUpdateQueue 执行每个 callback 回调函数。接下来会更新 ref 属性。

useEffect 执行是通过flushPassiveEffects 去执行的，而flushPassiveEffects 是在 scheduleCallback 中执行的。scheduleCallback 是采用异步模式下进行的，所以 useEffect 的钩子函数是在异步条件下执行的。flushPassiveEffects 本质上会调用 flushPassiveEffectsImpl 。 flushPassiveEffectsImpl 内部会执行 commitPassiveMountEffects 。

commitPassiveMountEffects 会通过 begin ，complete 来从上到下找到最底部 fiber ，然后再从下到上执行 fiber 树上的所有的 effect，最后再执行 commitPassiveMountOnFiber。commitPassiveMountOnFiber 如果是函数组件，会通过 commitHookEffectListMount 执行所有的 useEffect 钩子函数。

## 总结

在R17之前，commit是通过循环由render阶段收集来的effectlist链去进行effect的处理的，并且还分成了三个阶段去进行处理，这样保证了不同的生命周期函数被合适的调用，也保证了不同的Effect在不同的时间被调用。而在R17之后，循环effectlist链的方式被移除，取而代之的是从rootFiber自上而下的遍历方式去调和进行处理和更新，跟Render阶段的begin-complete相似但又有一些不同，begin采用一直向下找到最底层具有`Before Mutation`标志的fiber，然后开始complete，但是在complete的回溯过程中并不会再去执行begin，而是只执行complete。三个阶段和effect都是采用这种方式去进行处理。
