# Ray

## 射线

+   射线由一个起点和方向构成 

```js
class Ray {
    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
        this.origin = origin;//起点
        this.direction = direction;//方向
    }
    set(origin, direction) {//不创建新的实例来修改值
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    }
    copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    }
    at(t, target) {
        //此处看成坐标，方法作用为沿着射线方向给出指定距离的坐标
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
        //得到一条由起始点指向v的方向向量
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    }
    recast(t) {
        //重新设置射线的起点为给定距离的射线方向的位置坐标
        this.origin.copy(this.at(t, _vector$a));
        return this;
    }
    closestPointToPoint(point, target) {
        //给出一个点point，如果这个点与起点的方向向量和射线的方向角度大于180则返回起点
        //否则，返回一个point在射线方向上的投影长度等距的射线方向上的坐标
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) {
            return target.copy(this.origin);
        }
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
        //返回距离的幂
        return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
        //整体思想就是 如果point和起点构成的方向向量与射线方向的夹角大于180则取point与起点的距离，否则就取point在射线方向上的投影点到起点的距离
        const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
        // 指向射线后面
        if (directionDistance < 0) {//如果方向相反(点乘小于0)
            return this.origin.distanceToSquared(point);//两点之间的距离
        }
        _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        //...
        //获取此射线与线段之间的平方距离。
    }
    intersectSphere(sphere, target) {//返回交点
        /**
		球面S: F(X) =|| X - C ||^2 = R^2
         射线L:L(t) = P + t·d
         代入 ||(P + t·d) - C||^2 = R^2 <==>
         (||d||^2)(t^2) + 2t[d·(P-C)] + (P-C)·(P-C) - R^2 = 0
         类似at^2 + 2bt + c = 0
         运用一元二次求解公式
         Δ = [d·(P-C)]^2 - (P - C)·(P - C) + R^2
         t = (-d·(P-C)±√Δ)/||d||^2
         	Δ大于0，有两个交点
         	即[d·(P-C)]^2 + R^2 > (P - C)·(P - C)
         	R^2 > (P - C)·(P - C) - [d·(P-C)]^2
         链接：https://zhuanlan.zhihu.com/p/136763389
        **/
        _vector$a.subVectors(sphere.center, this.origin);//(C-P) <==>-(P-C)
        const tca = _vector$a.dot(this.direction);//d·(C-P)
        const d2 = _vector$a.dot(_vector$a) - tca * tca;//(C - P)·(C - P) - [d·(C-P)]^2
        const radius2 = sphere.radius * sphere.radius;//R^2
        if (d2 > radius2) return null;//Δ小于0 无解 即无交点
        const thc = Math.sqrt(radius2 - d2);//根号Δ
        const t0 = tca - thc;//由于公式是P-C 我们最开始是C - P 偶幂时无影响，奇幂时取负
        const t1 = tca + thc;
        if (t0 < 0 && t1 < 0) return null;
        //测试t0是否在射线后面：
        //如果是，则光线位于球体内部，因此返回第二个按t1缩放的出口点，
        //以始终返回光线前面的交点。
        if (t0 < 0) return this.at(t1, target);
        // 否则t0在光线前面，因此返回按t0缩放的第一个碰撞点
        return this.at(t0, target);
        //返回的是交点
    }
    intersectsSphere(sphere) {//返回boolean
        return this.distanceSqToPoint(sphere.center) <= (sphere.radius * sphere.radius);
    }
    distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {//平行
            //直线是共面的，返回原点
            if (plane.distanceToPoint(this.origin) === 0) {//计算点到平面的距离
                return 0;
            }
            /**
            distanceToPoint(point) {return this.normal.dot(point) + this.constant;}由于normal为单位向量所以分母省去
            **/
            return null;
        }
        //分母应该是射线方向与平面法向量的夹角，由于denominator = ||a||*||b||*cos<a,b> ;a,b为单位向量所以由于denominator = cos<a,b>，如果相交denominator在计算时会是负数，因为射线朝着平面射去，计算时角度为钝角
        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {//返回交点
        const t = this.distanceToPlane(plane);
        if (t === null) {
            return null;
        }
        return this.at(t, target);
    }
    intersectsPlane(plane) {//返回boolean
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
            return true;
        }
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
            return true;
        }
        return false;
    }
    intersectBox(box, target) {//返回交点
        //...
    }
    intersectsBox(box) {//返回boolean
        return this.intersectBox(box, _vector$a) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {//返回交点
			//...
    }
    applyMatrix4(matrix4) {//乘矩阵
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
    }
    equals(ray) {//判断是否相同
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {//ke'long
        return new this.constructor().copy(this);
    }
}
```