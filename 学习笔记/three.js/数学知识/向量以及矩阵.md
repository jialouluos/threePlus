# 向量以及矩阵

## 1.向量Vector3

+ 即可以表示一个方向也可以表示一个坐标

+ 主要API

  + 构造函数

    ```javascript
    //构造
    constructor( x = 0, y = 0, z = 0 ) {
    	this.x = x;
    	this.y = y;
    	this.z = z;
    }
    //EG:
    const v1 =new THREE.Vector3(5,2,0);
    ```
  
  + clone()
  
    ```javascript
    //克隆
    clone() {
    	return new this.constructor( this.x, this.y, this.z );
    }
    //EG:
    const v1 = new THREE.Vector3(1,2,3);
    const v2 = v1.clone();//这里是深拷贝，深拷贝是在堆中重新开辟一个内存来存放拷贝对象的值，每一集别的数据都会被复制，v1和v2两者互不影响
    const v3 = v1;//这里是浅拷贝，拷贝引用，v1v3两者指向同一片地址
    ```

  + copy()
  
    ```javascript
    //复制
    copy( v ) {
    	this.x = v.x;
    	this.y = v.y;
    	this.z = v.z;
    	return this;
    }
    //EG:
    const v1 = new THREE.Vector3(1,2,3);
    const v2 = new THREE.Vector3(4,5,6);
    v2.copy(v1);//会改变v2的值，v2的值现在是(1,2,3)
    ```
  
  + add()
  
    ```javascript
    //加
    add( v, w ) {
    	if ( w !== undefined ) {
    		console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    		return this.addVectors( v, w );
    	}
    	this.x += v.x;
    	this.y += v.y;
    	this.z += v.z;
    	return this;
    }
    addVectors( a, b ) {
    	this.x = a.x + b.x;
    	this.y = a.y + b.y;
    	this.z = a.z + b.z;
    	return this;
    }
    //EG:
    const v1 = new THREE.Vector3(1,2,3);
    const v2 = new THREE.Vector3(3,4,5);
    //add具有修正判断，当我们不小心传入第二个向量参数时，会发出警告，然后还是会帮我们调用正确的API:addVectors()
    const v3 = v2.add(v1);//v3(4,6,8),注意此时v3和v2指向同一个向量对象
    const v4 = v2.clone().add(v1);//若想v4是一个独有的对象，这样写即可
    //或者调用 addVectors
    const v5 =new THREE.Vector3();
    v5.addVectors(v1,v2);
    ```
  
  + sub
  
    ```js
    //减
    sub( v, w ) {
    	if ( w !== undefined ) {
    		console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    		return this.subVectors( v, w );
    	}
    	this.x -= v.x;
    	this.y -= v.y;
    	this.z -= v.z;
    	return this;
    	}
    //和上面add的方法一样
  
  + multiply()
  
    ```js
    //乘
    multiply( v, w ) {
    	if ( w !== undefined ) {
    		console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
    		return this.multiplyVectors( v, w );
    	}
    	this.x *= v.x;
    	this.y *= v.y;
    	this.z *= v.z;
    	return this;
    }
    //EG:
    const v1 = new THREE.Vetor3(1,2,3)；
    const v2 = new THREE.Vector3(1,2,2);
    v2.multiply(v1);//v2(1,4,6)
    //还有一种乘是向量x标量
    multiplyScalar( scalar ) {
    	this.x *= scalar;
    	this.y *= scalar;
    	this.z *= scalar;
    	return this;
    }
    //EG:
    const v3 = new THREE.Vetor3(1,2,3)；
    const num1 = 4;
    v2.multiplyScalar(num1);//v3(4,8,12)
    ```
  
  + divide
  
    ```js
    //除
    divide( v ) {
    	this.x /= v.x;
    	this.y /= v.y;
    	this.z /= v.z;
    	return this;
    }
    divideScalar( scalar ) {
    	return this.multiplyScalar( 1 / scalar );
    }
    ```
  
  + length()
  
    ```js
    //向量的长度,计算当前向量与（0，0，0）的距离
    length() {
    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
    }
  
  + normalize()
  
    ```js
    //归一化
    normalize() {
    	return this.divideScalar( this.length() || 1 );
        cons
    }
    /**
    *@归一化，归一化就是要把需要处理的数据经过处理后（通过某种算法）限制在你需要的一定范围内。简单来说就是将一个向量的每一个分量映射到0~1之间，这里选用的是将向量的长度作为分母，每个向量分量作为分子，例如向量（1,2,3），其对应的归一化向量计算方式为：分母:√(1²+2²+3²)，x：1/√(1²+2²+3²),y：2/√(1²+2²+3²),z：3/√(1²+2²+3²),故归一化向量为(1/√14,2/√14,3/√14)
    **/
  
  + dot()
  
    ```js
    //点乘
    dot( v ) {
    	return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    //可以联想两个向量求余弦时的分子，就是两个向量dot
    //EG:求两向量之间的夹角
    const v1 = new THREE.Vector3(0,1,0);
    const v2 = new THREE.Vector3(1,0,0);
    const dot_m = v1.dot(v2);//这里不会改变自身，所以不需要clone()
    const dot_d = v1.length() * v2.length();
    const result = Math.acos(dot_m/dot_d);//反三角函数，得到一个数的反余弦值(单位为弧度)
    const angle = result*180/Math.PI;//得到角度值
    //angle为所求90
    ```
  
  + cross()
  
    ```js
    //叉乘
    cross( v, w ) {
    	if ( w !== undefined ) {
    		console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
    		return this.crossVectors( v, w );
    	}
    	return this.crossVectors( this, v );
    }
    crossVectors( a, b ) {
    	const ax = a.x, ay = a.y, az = a.z;
    	const bx = b.x, by = b.y, bz = b.z;
    	this.x = ay * bz - az * by;
    	this.y = az * bx - ax * bz;
    	this.z = ax * by - ay * bx;
    	return this;
    }
    //实质都是调用crossVectors这个API
    /**
    *@叉乘：又叫叉积，计算方式为 aXbXsinθ,两向量平行叉积为0，两向量垂直叉积为1,在这里可以这样理解
    *				|  i   j   k  |	
    *				| a.x a.y a.z |
    *				| b.x b.y b.z |
    * 叉乘的计算方式为 (a.y * b.z - a.z * b.y) * i + (a.z * b.x - a.x * b.z) * j + (a.x * b.y - a.y * b.x) * k
    * 这里的 i j k 为 1
    **/
    //EG:
    //求一个球的面积
    /**先来找一个简易的几何体的部分面积（斜平面）
    *A(2,0,0),B(0,2,0),C(0,0,2),利用叉乘的思想，先找到这个平面的两条向量，这里选用 A-B 和 A-C来作为向量
    *记A-B为a1，A-C为a2，计算结果在a3向量中，a1=(2,-2,0),a2=(2,0,-2),先利用crossVectorsAPI得出a3=(-4,-4,-4);
    *然后我们需要求出a3到（0，0，0）距离,也就是a3.length() 这样可以得到类比于二维平面计算面积公式0.5 * aXbXsinθ 中的*aXbXsinθ部分，我们还需要乘0.5才能得到面积，所以需要将a3.length()/2;
    *a3.length() == aXbXsinθ 其实就是一个数学变形(这里特别感谢璨璨学姐，我脑壳笨以为是啥高级定理，结果...)
    *令a3.length()=左边，aXbXsinθ=右边，为方便书写，我将两个向量名为为v1(x1,y1,z1),v2(x2,y2,z2),同时左右两边同时平方
    * 左边² = (y1*z2-z1y2)²+(z1x2-x1z2)²+(x1y2-y1x2)²
    * 右边² = (x1²+y1²+z1²)*(x2²+y2²+z2²)*(1-cos²θ) = (x1²+y1²+z1²)*(x2²+y2²+z2²)*(1-(x1x2+y1y2+z1z2)²/[
    * (x1²+y1²+z1²)(x2²+y2²+z2²)]);
    *将左右两边同时展开，所有项都可抵消，所以该式成立
    **/
    //所以对于一个由Geometry构成的几何体，我们需要得到他每个平面得顶点坐标
    const geometry = new THREE.SphereGeometry(10,10,10);//arg[0]表示半径，arg[1]表示水平段的数量，arg[2]表示垂直段数
    let result_area =0.0;//保存最后的面积
    for(let i=0;i<geometry.faces.length;i++){
        let f1 = geometry.faces[i].a;//faces保存着一个面的三个顶点索引
        let f2 = geometry.faces[i].b;//我们可以通过这个索引来去读取该索引对应的顶点数据
        let f3 = geometry.faces[i].c;//该索引也就是顶点数组中的下标索引
        let p1 = geometry.vertices[f1];
        let p2 = geometry.vertices[f2];
        let p3 = geometry.vertices[f3];
        result_area+=GetArea(p1,p2,p3);
    }
    function GetArea(p1,p2,p3){
        const v1 = p1.clone().sub(p2);
        const v2 = p1.clone().sub(p2);
        const v3 = new THREE.Vetor3();
        v3.crossVectors(v1,v2);
        return v3.length()/2;
    }
    ```
  
    <img src="https://jialouluoblog.oss-cn-hongkong.aliyuncs.com/markdownimg/image-20211225214414102.png" alt="image-20211225214414102" style="zoom:50%;" />
  
  + lerp()
  
    ```js
    //线性插值
    lerp( v, alpha ) {
    	this.x += ( v.x - this.x ) * alpha;
    	this.y += ( v.y - this.y ) * alpha;
    	this.z += ( v.z - this.z ) * alpha;
    	return this;
    }
    ```

## 2.矩阵



+ 通过elements来储存矩阵的值，默认矩阵为单位矩阵(对角线全为1)

+ 矩阵的一些推导

  ![img](https://img-blog.csdn.net/20170509211752890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAxMDAwNDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

  <img src="https://img-blog.csdn.net/20170509220125255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzAxMDAwNDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:60%;" />

  $$
  1.旋转(例：绕z轴旋转)\\
  假设我们从p旋转到p'，设p的极径为r，那么p'的极径也为r，设p与x轴之间的夹角为ɑ以及p与p'之间的夹角为θ\\
  根据三角变换，可以推理出来\\
  sinɑ = y/r\\cosɑ = x/r\\sin(ɑ+θ) = y'/r\\cos(ɑ+θ) = x'/r\\
  由于p与p'之间通过r这个相同量连接所以我们可以通过r来进行一些变换\\
  r = x/cosɑ①\\ r = y/sinɑ②\\r = x'/cos(ɑ+θ)③\\r = y'/sin(ɑ+θ)④\\
  又有二角和公差\\
  cos(ɑ+θ) = cosɑcosθ - sinɑsinθ\\sin(ɑ+θ) = sinɑcosθ + cosɑsinθ\\
  所以\\r = x'/(cosɑcosθ - sinɑsinθ)\\r = y'/(sinɑcosθ + cosɑsinθ)\\
  所以\\x' = r*(cosɑcosθ - sinɑsinθ)\\y' = r*(sinɑcosθ + cosɑsinθ)\\
  展开\\x' = r*cosɑcosθ - r*sinɑsinθ==>x' = xcosθ - ysinθ\\
  y' = r*sinɑcosθ + r*sinɑsinθ==>y' = ycosθ + xsinθ\\
  绕z轴旋转\\
   \begin{bmatrix}
     x' \\
     y' \\
     z' \\
     1  \\ 
    \end{bmatrix}=\begin{bmatrix}
     cosθ & -sinθ &  0 & 0 \\
     sinθ & cosθ  &  0 & 0 \\
     0    &  0    &  1 & 0 \\
     0    &  0    &  0 & 1\\ 
    \end{bmatrix}*\begin{bmatrix}
     x \\
     y \\
     z \\
     1  \\ 
    \end{bmatrix}
    \\
    绕x轴旋转\\
   \begin{bmatrix}
     x' \\
     y' \\
     z' \\
     1  \\ 
    \end{bmatrix}=\begin{bmatrix}
     1 &  0   &   0   & 0 \\
     0 & cosθ & -sinθ & 0 \\
     0 & sinθ & cosθ  & 0 \\
     0 &  0   &   0   & 1 \\ 
    \end{bmatrix}*\begin{bmatrix}
     x \\
     y \\
     z \\
     1  \\ 
    \end{bmatrix}
    \\
    绕y轴旋转\\
   \begin{bmatrix}
     x' \\
     y' \\
     z' \\
     1  \\ 
    \end{bmatrix}=\begin{bmatrix}
     cosθ & -sinθ & 0 & 0 \\
     0    &   1   & 0 & 0 \\
     sinθ &  cosθ & 0 & 0 \\
     0    &   0   & 0 & 1 \\ 
    \end{bmatrix}*\begin{bmatrix}
     x \\
     y \\
     z \\
     1  \\ 
    \end{bmatrix}
    \\
    2.平移\\
    影响平移的是第四列\\
     \begin{bmatrix}
     x' \\
     y' \\
     z' \\
     1  \\ 
    \end{bmatrix}=\begin{bmatrix}
     1 & 0 & 0 & Tx \\
     0 & 1 & 0 & Ty \\
     0 & 0 & 1 & Tz \\
     0 & 0 & 0 & 1\\ 
    \end{bmatrix}*\begin{bmatrix}
     x \\
     y \\
     z \\
     1 \\ 
    \end{bmatrix}
    \\
    3.缩放\\
    缩放对应的就是对角线的值\\
      \begin{bmatrix}
     x' \\
     y' \\
     z' \\
     1  \\ 
    \end{bmatrix}=\begin{bmatrix}
     Sx & 0 & 0 & 0 \\
     0 & Sy & 0 & 0 \\
     0 & 0 & Sz & 0 \\
     0 & 0 & 0 & 1\\ 
    \end{bmatrix}*\begin{bmatrix}
     x \\
     y \\
     z \\
     1 \\ 
    \end{bmatrix}
  $$

+ 矩阵常用对应值表

  | Sx   | 0    | 0    | Tx   |
  | ---- | ---- | ---- | ---- |
  | 0    | Sy   | 0    | Ty   |
  | 0    | 0    | Sz   | Tz   |
  | 0    | 0    | 0    | 1    |

  

+ 常用API

  + 构造函数

    ```js
    //构造函数
    constructor() {
    	this.elements = [
    		1, 0, 0, 0,
    		0, 1, 0, 0,
    		0, 0, 1, 0,
    		0, 0, 0, 1
    	];
    	if ( arguments.length > 0 ) {
    		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
    	}
    }
    set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
    	const te = this.elements;
    	te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    	te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    	te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    	te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
    	return this;
    }
    //只能构造默认的矩阵，如果需要自定义矩阵可以使用set方法
    //EG:
    const m1 = new THREE.Matrix4();
    m1.set(1,3,4,5,
           0,2,4,5,
           1,3,4,5,
           2,5,0,3);//这里需要注意一下，储存的时候是按照传入参数的转置矩阵来存的，计算不用担心，因为所有矩阵都被转置了，我们常用的缩放矩阵值对应0,5,10,平移矩阵值对应12，13，14，旋转矩阵值对应0，1，4，5
    ```

  + clone()

    ```js
    //克隆
    clone() {
    	return new Matrix4().fromArray( this.elements );
    }
    fromArray( array, offset = 0 ) {
    	for ( let i = 0; i < 16; i ++ ) {
    		this.elements[ i ] = array[ i + offset ];
    	}
    	return this;
    }//和Vector3原理一样
    ```

  + copy()

    ```js
    //复制
    copy( m ) {
    	const te = this.elements;
    	const me = m.elements;
    	te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
    	te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
    	te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
    	te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];
    	return this;
    }
    ```

  + multiply & premultiply 

    ```js
    //矩阵乘法
    multiply( m, n ) {//左乘
    	if ( n !== undefined ) {
    		console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
    		return this.multiplyMatrices( m, n );
    	}
    	return this.multiplyMatrices( this, m );
    }
    premultiply( m ) {//右乘
    	return this.multiplyMatrices( m, this );
    }
    multiplyMatrices( a, b ) {//乘法规则
    	const ae = a.elements;
    	const be = b.elements;
    	const te = this.elements;
    	const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    	const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    	const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    	const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
    	const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    	const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    	const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    	const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
    	te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    	te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    	te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    	te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    	te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    	te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    	te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    	te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    	te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    	te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    	te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    	te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    	te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    	te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    	te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    	te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    	return this;
    }
    ```

  + 转置

    ```js
    //转置
    transpose() {
    		const te = this.elements;
    		let tmp;
    		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
    		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
    		return this;
    	}
    ```

  + invert()

    ```js
    //求一个矩阵的逆矩阵
    ```

  + determinant()

    ```js
    //求一个矩阵的行列式
    ```

  + EG

    ```js
    const m1 = new THREE.Matrix4();//创建一个4x4矩阵
    m1.set(1,0,0,5,0,1,0,3,0,0,1,9,0,0,0,1);
    const m2 = m1.clone().transpose();//m2为m1的转置矩阵
    const m3 = m1.clone().multiplyMatrices(m2);//矩阵相乘
    const m4 = m1.clone().multiplyScalar(10);//将每一个量都扩大10倍
    const m5 = m1.clone().invert();//m1的逆矩阵
    const value1  = m1.clone().determinant();//m1的行列式
    ```

+ 变换矩阵API

  ```js
  const m1 = new THREE.Matrix4();
  //绕x轴旋转
  m1.makeRotationX(angle);
  //绕y轴旋转
  m1.makeRotationY(angle);
  //绕z轴旋转
  m1.makeRotationZ(angle);
  //缩放
  m1.makeScale(Sx,Sy,Sz);
  //平移
  m1.makeTranslation(Tx,Ty,Tz);
  //向量矩阵变换
  const m2 = new THREE.Matrix4();
  m2.makeTranslation(14,16,54);
  const v1 =new THREE.Vector3(10,10,10);
  v1.clone().applyMaterix4(m2);
  //结果是v1(24，26，64)
  //旋转矩阵：Rx*Ry*Rz
  Web
  //*模型矩阵：旋转矩阵*缩放矩阵*平移矩阵
  ```

+ 投影矩阵、视图矩阵

  ## Three.js 中的两个相机

#### 					 相机对象属性`.matrixWorldInverse`和`.projectionMatrix`

正投影相机的的基类是Camera，Camera具有一个视图矩阵属性`.materixWorldInverse`,和一个投影矩阵属性`.projectionMatrix`相机对象的本质就是视图矩阵和投影矩阵，顶点坐标经过平移旋转缩放模型变换之后，还需要经过`视图矩阵`、`投影变换`才能显示到画布上

#### 			正投影相机OrthographicCamera


##### 	`Matrix4`方法：正投影`.makeOrthographic()`
矩阵对象`Matrix4`的方法`.makeOrthographic()`封装了正投影的算法，该方法用来创建一个正投影矩阵，在正投影相机对象`OrthographicCamera`中会调用该方法更新相机对象的投影矩阵属性`.projectionMatrix`
方法参数：`.makeOrthographic( left,right,top,bottom,near,far)`

正投影相机`OrthographicCamera`类封装调用了矩阵对象`Matrix4`的正投影矩阵变换方法`.makeOrthographic()`。执行该方法用来改变正投影相机对象的投影矩阵属性`.projectionMatrix`。

```JavaScript
// OrthographicCamera.js源码
this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far )
```

构造函数`OrthographicCamera(left,right,top,bottom,near,far)`

```js
var width = window.innerWidth; //窗口宽度
var height = window.innerHeight; //窗口高度
var k = width / height; //窗口宽高比
var s = 150; //三维场景显示范围控制系数，系数越大，显示的范围越大
//创建相机对象
var camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);//构造函数会自动调用updateProjectionMatrix方法，updateProjectionMatrix方法会调用this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far )
camera.position.set(200, 300, 200); //设置相机位置
camera.lookAt(scene.position); //设置相机方向(指向的场景对象)
```

#### 正投影相机`PerspectiveCamera`

##### 	`Matrix4`方法：正投影`.makePerspective()`

矩阵对象`Matrix4`的方法`.makePerspective()`封装了透视投影的算法，该方法用来创建一个透视投影矩阵，在透视投影相机对象`PerspectiveCamera`中会调用该方法更新相机对象的投影矩阵属性`.projectionMatrix`
方法参数：`.makePerspective( left,right,top,bottom,near,far)`

透视投影相机`PerspectiveCamera`类封装调用了矩阵对象`Matrix4`的透视投影矩阵变换方法`.makePerspective()`。执行该方法用来改变透视投影相机对象的投影矩阵属性`.projectionMatrix`。

透视投影相机`PerspectiveCamera`类封装调用了矩阵对象`Matrix4`的透视投影矩阵变换方法`.makePerspective()`。执行该方法用来改变透视投影相机对象的投影矩阵属性`.projectionMatrix`。

```JavaScript
// PerspectiveCamera.js源码
this.projectionMatrix.makePerspective(left, right, top, bottom, this.near, this.far);
```

构造函数`PerspectiveCamera(fov,aspect,near,far)`

透视投影相机使用例子

```JavaScript
var width = window.innerWidth; //窗口宽度
var height = window.innerHeight; //窗口高度
/**透视投影相机对象*/
var camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000);//构造函数会自动调用updateProjectionMatrix方法，updateProjectionMatrix方法会调用this.projectionMatrix.makePerspective( left, right, top, bottom, this.near, this.far )
camera.position.set(200, 300, 200); //设置相机位置
camera.lookAt(scene.position); //设置相机方向(指向的场景对象),此处的lookAt是基类Object3D的一个方法
lookAt( x, y, z ) {
		// This method does not support objects having non-uniformly-scaled parent(s)
	if ( x.isVector3 ) {
		_target.copy( x );
	} else {
		_target.set( x, y, z );
	}
    ...
}
```

#### Matrix4方法：.lookAt()

矩阵对象`Matrix4`的`.lookAt()`方法对图形学中投影矩阵算法进行了封装，也就是通过给定的参数生成变换矩阵，视图矩阵和模型矩阵一样会用于场景中对象的平移旋转等变换，该方法通常用于构建相机对象的视图矩阵`.matrixWorldInverse`属性。
参数：`.lookAt(eye,center, up )`
三个参数都是三维向量对象`Vector3`，eye是视点也就是观察位置，center表示被观察的位置，up表示向上的方向。

### `Object3D`方法`.lookAt(x,y,z)`

`Object3D`类封装了矩阵对象`Matrix4`的`.lookAt()`方法，得到一个新的方法`.lookAt(x,y,z)`,参数表示xyz是相机的目标观察点。

通过`Object3D`对象的`.lookAt(x,y,z)`方法可以改变自身的四元数属性`.quaternion`,四元数属性`.quaternion`和对象角度属性`rotaion`一样表示对象的旋转变换，可以转化为旋转矩阵，进而改变对象的本地矩阵属性`.matrix`和世界矩阵属性`.matrixWorld`。

```JavaScript
// Object3D.js源码
// `.lookAt()`方法计算得到的旋转矩阵对象m1改变对象的四元数属性.quaternion
this.quaternion.setFromRotationMatrix( m1 );
```

### 相机对象

透视投影相机`PerspectiveCamera`和正投影相机`OrthographicCamera`的基类是相机对象`Camera`，相机对象的基类是`Object3D`，所以相机对象会继承`Object3D`的`.lookAt(x,y,z)`方法，勇于改变自身的矩阵属性。

Object3D` → `Camera` → `PerspectiveCamera
Object3D` → `Camera` → `OrthographicCamera

相机对象的视图矩阵属性`matrixWorldInverse`，字面意思是世界矩阵逆矩阵的意思，这可以看出来相机对象的视图矩阵属性就是自身世界矩阵`matrixWorld`的逆矩阵`invert()`。

设置相机对象的位置属性和lookAt方法本质就是==改变自身的视图矩阵属性`matrixWorldInverse`。==

```JavaScript
var camera = new THREE.OrthographicCamera(...);
//设置相机位置
camera.position.set(200, 300, 200);
//设置相机对象的观察目标的位置
camera.lookAt(scene.position);
```
