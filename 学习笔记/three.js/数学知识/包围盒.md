# 包围盒

​		包围盒是一种计算一系列顶点的最优包围空间的算法，最简单的理解就是用一个体积最小的正方体来包围一个圆，这个正方体就是包围盒，Three.js对包围盒封装了3个API，分别是三维包围盒Box3，包围球Sphere，包围矩形Box2

## 包围矩形Box2

+   该方法通常用一个矩形区域来包围一个二维平面，使用min和max两个属性来描述该矩形区域，属性值都是Vector2，通过Box2的构造函数可以直接设置min，max的值，也可以通过一些方法来设置。描述一个矩形区域通常需要x，y坐标来表示。x范围[Xmin,Xmax],y范围[Ymin,Ymax],`.min`的属性值是`Vector2(Xmin,Ymin)`,`.max`的属性值是`Vector2(Xmax,Ymax)`

+   构造函数

    ```js
    constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {
    	this.min = min;
    	this.max = max;
    }
    //EG:
    const box2 = new THREE.Box2(new THREE.Vector2(-1,-1),new THREE.Vector2(3,4));
    //或通过一些方法
    box2.min=new THREE.Vector2(-3,-2);
    box2.max=new THREE.Vector2(3,2);
    ```

+   setFromPoints()

    ```js
    setFromPoints( points ) {
    	this.makeEmpty();//初始化
    	for ( let i = 0, il = points.length; i < il; i ++ ) {
    		this.expandByPoint( points[ i ] );
    	}
    	return this;
       /**
       *@主要思想就是遍历每个顶点，min的思想是如果当前顶点的某一方量坐标值比当前最小值还小就做替换，max的思想是如果当前顶点的某一方量坐标值比当前最大值还大就做替换
       **/
    }
    makeEmpty() {//初始化
    	this.min.x = this.min.y = + Infinity;
    	this.max.x = this.max.y = - Infinity;
    	return this;
    }
    expandByPoint( point ) {
    	this.min.min( point );
    	this.max.max( point );
    	return this;
    }
    min( v ) {
        //这里的this指的是min和max，并非Box2对象
    	this.x = Math.min( this.x, v.x );
    	this.y = Math.min( this.y, v.y );
    	return this;
    }
    max( v ) {
    	this.x = Math.max( this.x, v.x );
    	this.y = Math.max( this.y, v.y );
    	return this;
    }
    ```

+   getCenter()

    ```js
    //获取一个包围盒的几何中心
    getCenter( target ) {//通常target是一个Vector2(0,0),或者Vector3(0,0,0);即一个初试向量
    		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );//min与max相加取一半并赋值给target
    }
    isEmpty() {
    	return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );//如果最大值比最小值还小，则该包围盒不合法，所以为判空.
    }

+   getSize()

    ```js
    getSize( target ) {
    	return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );
        //获取包围盒大小，结果作为Vector赋值给target
    }
    ```

+   expandByScalar()

    ```js
    expandByScalar( scalar ) {
        this.min.addScalar( - scalar );
        this.max.addScalar( scalar );
        return this;
    }
    //这里我看网上的理解：scalar是扩张倍数，但是我翻看源码发现他似乎是给当前的范围增加一个标量，而并非乘一个标量
    //所以需要用代码来检测一下结果
    //EG:
    const box2 = new THREE.Box2(new THREE.Vector2(1,-1),new THREE.Vector2(3,4));
    box2.expandByScalar(2);
    console.log(box2)//mix:(-1,-3),max(5,6),所以他这里应该是给当前包围盒增加一个标量的距离。并非乘一个标量
    ```

    ## 包围盒Box3

+   构造函数

    ```js
    //形式和Box2基本一致
    constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {
        this.min = min;
        this.max = max;
    }
    const box3 = new THREE.Box3( new THREE.Vector3(-10, -10,0),new THREE.Vector3(100, 20,50));
    //或通过一些方法
    box3.min = new THREE.Vector3(-10, -10,0);
    box3.max = new THREE.Vector3(100, 20,50);
    ```

+   expandByObject()

    ```js
    const _box$3 = /*@__PURE__*/ new Box3();
    const _points = [
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3()
    ];
    expandByObject( object ) {//这里使用了递归遍历，对于每一个object访问其的geometry属性，如果存在则计算包围盒，如果不存在，则遍历他的子代
        // 计算对象（包括其子对象）的世界轴对齐边界框，
        //同时考虑对象和子对象的世界变换
        object.updateWorldMatrix( false, false );//更新矩阵
        const geometry = object.geometry;
        if ( geometry !== undefined ) {
            if ( geometry.boundingBox === null ) {//计算几何体的包围盒属性boundingBox默认值为空null执行geometry.computeBoundingBox()方法才会计算该几何体的包围盒Box3，然后赋值给.boundingBox属性。
                geometry.computeBoundingBox();
            }
            _box$3.copy( geometry.boundingBox );//copy包围盒的值
            _box$3.applyMatrix4( object.matrixWorld );//同步矩阵属性，更新包围盒坐标
            this.union( _box$3 );//更新比较包围盒值
        }
        const children = object.children;
        for ( let i = 0, l = children.length; i < l; i ++ ) {
            this.expandByObject( children[ i ] );
        }
        return this;
    }
    computeBoundingBox() {
        if ( this.boundingBox === null ) {
            this.boundingBox = new Box3();
        }
        this.boundingBox.setFromPoints( this.vertices );
    }
    applyMatrix4( matrix ) {
        // transform of empty box is an empty box.
        if ( this.isEmpty() ) return this;
        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        _points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
        _points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
        _points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
        _points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
        _points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
        _points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
        _points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
        _points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111
        this.setFromPoints( _points );
        return this;
        //Vector3.applyMatrix4(m);//将此向量（在第 4 维中隐含 1）与 m 相乘，然后除以透视图。,暂时理解为更新顶点位置
        //再一个集合体中，顶点位置生成时已经确定了，在后续的几何体移动中，我们需要得到更新后的顶点坐标，这时需要将顶点.applyMatrix4(一个模型矩阵);这样才能够得到正确有意义的坐标，同时包围盒这里同样可以这样理解，包围盒只保存了大小，但如果几何体本身在后续操作中进行了一些变换操作，这时候需要将包围盒也applyMatrix4才能够得到更新后的包围盒
    }
    union( box ) {
        this.min.min( box.min );
        this.max.max( box.max );
        return this;
    }
    //EG:
    const loader = new THREE.ObjectLoader();
    loader.load('group.json', function(group) {
        scene.add(group);//加载返回的模型对象插入场景
        const box3 = new THREE.Box3()
        // 计算层级模型group包围盒
        box3.expandByObject(group)
        console.log('查看包围盒box3', box3);
    })
    
    ```

    ## 包围球Sphere

+   包围球Sphere是一个球形的包围区域，通过球心坐标`.center`和半径`.radius`两个属性来描述.

    ```JavaScript
    // 创建一个包围球对象，球心默认坐标原点，半径默认0.
    var sphere = new THREE.Sphere()
    console.log('sphere', sphere);
    // 设置球心坐标
    sphere.center=new THREE.Vector3(-10, -10,0);
    // 设置包围球半径
    sphere.radius=20;
    //包围球可以想象成一个用一个最小的球体去包裹一个几何体，这个最小的球就是包围球
    ```

    ## 几何体居中

+   这是一个让一个几何体居中的案例

    ```etjs
    const Geometry = new THREE.BoxGeometry(50,50,50);
    const Material = new THREE.MeshBasicMaterial({color:"#ff0000"});
    console.log(geometry.vertices);
    console.log('查看几何体包围盒属性', geometry.boundingBox);//此时各方量的的min都为-25，max都为25
    Geometry.translate(100,10,0);//平移方法
    console.log(geometry.vertices)
    console.log('查看几何体包围盒属性', geometry.boundingBox);//此时x方量的min为75，max为125，y方量min为-15，max为35 ，z不变
    Geometry.center();
    console.log(geometry.vertices)
    console.log('查看几何体包围盒属性', geometry.boundingBox);//此时各方量的的min都为-25，max都为25
    const mesh =new THREE.Mesh(Geometry,Material);
    ```
