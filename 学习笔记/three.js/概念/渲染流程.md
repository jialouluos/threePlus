# 渲染流程

## this.render = function ( scene, camera )

```js
//记录主要流程
this.render = function ( scene, camera ){
    if ( scene.autoUpdate === true ) scene.updateMatrixWorld();//更新场景子代所有物体矩阵
    if ( camera.parent === null ) camera.updateMatrixWorld();//更新相机
    if ( xr.enabled === true && xr.isPresenting === true ) {//XR
        if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );
        camera = xr.getCamera();//这里是使用XR里面的相机替代我们传入的相机
    }
    if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );//渲染之前
    //上面可以理解为参数的某些更新
    //下面是渲染
    currentRenderState = renderStates.get( scene, renderStateStack.length );
    currentRenderState.init();
    /**
    renderStates = new WebGLRenderStates( extensions, capabilities );//对光源以及阴影进行二次封装
    extensions==>初始化启用一些WebGL扩展
    capabilities==>获取一堆gl环境中的最大值
    **/
    /**
   	get方法得到一个WeakMap(scene,[WebGLRenderState(extensions,capabilities)]),表示一个工厂函数，用于分类
    return {
		init: init,//初始化1
		state: state,//const state = {lightsArray: lightsArray,shadowsArray: shadowsArray,lights: lights};
		setupLights: setupLights,//灯光分类(猜测)
		setupLightsView: setupLightsView,//灯光分类有关(猜测)
		pushLight: pushLight,//增加灯光
		pushShadow: pushShadow//增加阴影
	};
    **/
    renderStateStack.push( currentRenderState );//添加进渲染栈中(一)
    _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );//透视矩阵X视图矩阵
    _frustum.setFromProjectionMatrix( _projScreenMatrix );
    _clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );//裁剪
    currentRenderList = renderLists.get( scene, renderListStack.length );
    currentRenderList.init();
    renderListStack.push( currentRenderList );//添加进渲染栈中(二)
    /**
    renderLists = new WebGLRenderLists( properties );//对渲染的对象进行排序
    properties==>由渲染器内部使用，以跟踪各种子对象属性。采用WeakMap即键（Object弱引用）值（any）的方式
	**/
    /**
    get方法得到一个WeakMap(scene,[WebGLRenderList(properties)]),表示一个工厂函数，用于渲染排序
    return {
		opaque: opaque,//不透明的渲染对象
		transmissive: transmissive,//穿透的渲染对象
		transparent: transparent,//透明的渲染对象
		init: init,//初始化
		push: push,//增加渲染对象并进行分类==>依据：透明，非透明，穿透
		unshift: unshift,//移除渲染对象
		finish: finish,//剔除废弃的渲染对象
		sort: sort//排序渲染对象
	};
    **/
    projectObject( scene, camera, 0, _this.sortObjects );//见第二个代码块，这里会将scene中所有的子代进行按类型进行不同的处理，如果是Mesh，Line，Point，Sprite，ImmediateRenderObject则会push进currentRenderList
    currentRenderList.finish();//剔除废弃的渲染对象
    if ( _this.sortObjects === true ) {//进行渲染排序
        currentRenderList.sort( _opaqueSort, _transparentSort );
    }
    if ( _clippingEnabled === true ) clipping.beginShadows();//待解析
    const shadowsArray = currentRenderState.state.shadowsArray;//待解析，应该跟阴影有关(猜测)
    shadowMap.render( shadowsArray, scene, camera );//待解析，应该跟阴影有关(猜测)
    currentRenderState.setupLights();//待解析，应该跟光照有关(猜测)
    currentRenderState.setupLightsView( camera );//待解析，应该跟光照有关(猜测)
    if ( _clippingEnabled === true ) clipping.endShadows();//待解析，应该跟裁剪有关(猜测)
    if ( this.info.autoReset === true ) this.info.reset();//具有一系列关于显卡内存和渲染过程的统计信息的对象。用于调试
    background.render( currentRenderList, scene );//待解析,应该跟背景有关(猜测)
    const opaqueObjects = currentRenderList.opaque;//这里提取的是上面分类之后的不透明对象数组
    const transmissiveObjects = currentRenderList.transmissive;//这里提取的是上面分类之后的穿透对象数组
    const transparentObjects = currentRenderList.transparent;//这里提取的是上面分类之后的透明对象数组
    //这里是绘制，即gl.drawArrays和gl.drawElements
    //主要关注renderObjects【一】
    if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );//不透明对象数组绘制
    if ( transmissiveObjects.length > 0 ) renderTransmissiveObjects( opaqueObjects, transmissiveObjects, scene, camera );//穿透对象数组绘制
    if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );//透明对象数组绘制
    ...
    //后面是一些收尾工作,待解析renderListStack的作用
}
```

## projectObject( scene, camera, 0, _this.sortObjects );

```js
//layers这可用于控制可见性 - 对象必须与相机共享一个图层才能在渲染该相机的视图时可见。
const visible = object.layers.test( camera.layers );//this 和传递的layers对象至少有一个共同的层，则返回 true。
const children = object.children;
if ( visible ){
    if ( object.isGroup ) {//组
        ...
    }
    else if ( object.isLOD ) {//细节层次
        ...
   	}
    else if ( object.isLight ) {
        ...
    } 
    else if ( object.isSprite ) {
        ...
        currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );//进行分类==>依据：透明，非透明，穿透
    }
    else if ( object.isImmediateRenderObject ) {//立即渲染对象，立即渲染物体和普通物体表现在代码上的区别是，
	// 没有用到顶点数组对象（Vertex Array Object，简称 VAO），立即渲染物体直接获取object上的position、normal、uv和color数据丢进buffer，进行绘制。
        ...
        currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );//进行分类==>依据：透明，非透明，穿透
    }
    else if ( object.isMesh || object.isLine || object.isPoints ) {
        ...
    	currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );//进行分类==>依据：透明，非透明，穿透
    }
}
for ( let i = 0, l = children.length; i < l; i ++ ) {
    projectObject( children[ i ], camera, groupOrder, sortObjects );
}
```

## renderObjects( opaqueObjects, scene, camera );

```js
const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;//overrideMaterial它将强制使用该材质渲染场景中的所有内容
for ( let j = 0, jl = renderList.length; j < jl; j ++ ) {
    const renderItem = renderList[ j ];//List中每个值都代表一个待绘制的对象
    const object = renderItem.object;
    const geometry = renderItem.geometry;
    const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
    const group = renderItem.group;
    renderObject( object, scene, camera, geometry, material, group );//主要关注renderObject【二】往下是单个对象的绘制
}
```

## renderObject( object, scene, camera, geometry, material, group );

```js
object.onBeforeRender( _this, scene, camera, geometry, material, group );
object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );//模型视图矩阵
object.normalMatrix.getNormalMatrix( object.modelViewMatrix );//法向矩阵
if ( material.transparent === true && material.side === DoubleSide ) {//这里解释了side的原理
    material.side = BackSide;
    material.needsUpdate = true;
    _this.renderBufferDirect( camera, scene, geometry, material, object, group );//主要关注renderBufferDirect【三】
    material.side = FrontSide;
    material.needsUpdate = true;
    _this.renderBufferDirect( camera, scene, geometry, material, object, group );
    material.side = DoubleSide;
} else {
    _this.renderBufferDirect( camera, scene, geometry, material, object, group );
}
object.onAfterRender( _this, scene, camera, geometry, material, group );
```

## renderBufferDirect( camera, scene, geometry, material, object, group );

```js
const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );
const program = setProgram( camera, scene, material, object );//这里返回的是一个WebGLProgram，详情见下一个代码块
//setProgram作用是设置该渲染对象的一些材质信息，比如光照信息，雾化信息，以及一些uniform值
state.( material, frontFaceCW );//详情见下面代码块
//setMaterial作用是设置三大缓冲区的相关信息以及一些正背面绘制的相关参数
let index = geometry.index;//顶点索引
const position = geometry.attributes.position;//坐标顶点
if (index === null) {
    if (position === undefined || position.count === 0) return;
} else if (index.count === 0) {
    return;
}
let rangeFactor = 1;
if (material.wireframe === true) {//显示网格线框
    index = geometries.getWireframeAttribute(geometry);
    rangeFactor = 2;
}
if (geometry.morphAttributes.position !== undefined || geometry.morphAttributes.normal !== undefined) {//几何体变形目标
    morphtargets.update(object, geometry, material, program);
}
bindingStates.setup(object, material, program, geometry, index);//setup是用来推入顶点相关的数据，使用了 VAO，几何体顶点的获取和更新，以及向attribute类型变量进行传值
let attribute;
let renderer = bufferRenderer;
if (index !== null) {
    //如果顶点索引恕不存在，则提取数据
    attribute = attributes.get(index);
    renderer = indexedBufferRenderer;
    renderer.setIndex(attribute);
    /**
             function setIndex( value ) {
		        type = value.type;
		        bytesPerElement = value.bytesPerElement;
	         }
             */
}
const dataCount = (index !== null) ? index.count : position.count;//数据数量
const rangeStart = geometry.drawRange.start * rangeFactor;//绘制范围-start,rangeFactor范围系数
const rangeCount = geometry.drawRange.count * rangeFactor;//绘制范围-end
const groupStart = group !== null ? group.start * rangeFactor : 0;
const groupCount = group !== null ? group.count * rangeFactor : Infinity;
const drawStart = Math.max(rangeStart, groupStart);//最终绘制起始
const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;//最终绘制中止
const drawCount = Math.max(0, drawEnd - drawStart + 1);//最终绘制数量
if (drawCount === 0) return;
if (object.isMesh) {
    if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());//光栅化时的线宽
        renderer.setMode(1);//_gl.LINES
    } else {
        renderer.setMode(4);//_gl.TRIANGLES
    }
}
else if (object.isLine) {
    let lineWidth = material.linewidth;
    if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material
    state.setLineWidth(lineWidth * getTargetPixelRatio());
    if (object.isLineSegments) {
        renderer.setMode(1);//_gl.LINES
    } else if (object.isLineLoop) {
        renderer.setMode(2);//_gl.LINE_LOOP
    } else {
        renderer.setMode(3);//_gl.LINE_STRIP
    }
}
else if (object.isPoints) {
    renderer.setMode(0);//_gl.POINTS
}
else if (object.isSprite) {
    renderer.setMode(4);//_gl.TRIANGLES
}
if (object.isInstancedMesh) {
    renderer.renderInstances(drawStart, drawCount, object.count);
} else if (geometry.isInstancedBufferGeometry) {
    const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
    renderer.renderInstances(drawStart, drawCount, instanceCount);
} else {
    renderer.render(drawStart, drawCount);//绘制
}
//
function setMode( value ) {
    mode = value;
}
function setIndex( value ) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
}
function render( start, count ) {
    gl.drawElements( mode, count, type, start * bytesPerElement );
    info.update( count, mode, 1 );
}
```

## setProgram( camera, scene, material, object );

```js
textures.resetTextureUnits();
//下面都是为绘制单个对象需要的一些属性数据
const fog = scene.fog;
const environment = material.isMeshStandardMaterial ? scene.environment : null;
const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;//定义渲染器的输出编码。默认为THREE.LinearEncoding。
const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );//环境贴图
const vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;//顶点颜色相关
const vertexTangents = object.geometry && object.geometry.attributes.tangent;//切线？
const morphTargets = object.geometry && object.geometry.morphAttributes.position;//morphM
const morphNormals = object.geometry && object.geometry.morphAttributes.normal;
const materialProperties = properties.get( material );//properties是一个工厂函数储存着四个方法，首次执行materialProperties的所有键值对都为undefined
/**
properties==>由渲染器内部使用，以跟踪各种子对象属性。采用WeakMap即键（Object弱引用）值（any）的方式
return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose,
	};
**/
const lights = currentRenderState.state.lights;
let needsProgramChange = false;
if ( material.version === materialProperties.__version ) {
    ...
    //一堆判定
    needsProgramChange = true;//判定为true则needsProgramChange设置为true
}
let program = materialProperties.currentProgram;//首次执行materialProperties的currentProgram为undefined
if ( needsProgramChange === true ) {//基本上每次执行到这里都会判定为true
    program = getProgram( material, scene, object );//返回一个WebGLProgram,首次执行materialProperties的currentProgram不为undefined
}
let refreshProgram = false;
let refreshMaterial = false;
let refreshLights = false;
const p_uniforms = program.getUniforms(),//获取程序中的uniform
      m_uniforms = materialProperties.uniforms;
if ( state.useProgram( program.program ) ) {//gl.useProgram(Program)，判断传入的WebGLProgram 对象是否存在于当前的渲染状态，如果不是，则添加到当前的渲染状态并返回true
    refreshProgram = true;
    refreshMaterial = true;
    refreshLights = true;
}
if ( material.id !== _currentMaterialId ) {
    _currentMaterialId = material.id;
    refreshMaterial = true;
}
if ( refreshProgram || _currentCamera !== camera ) {
    p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );//更新VertexShader中的矩阵
    //...
    //设置相机相关的矩阵的uniform
}
if ( object.isSkinnedMesh ){//骨骼网格
    //...
}
if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {//阴影
    //...
}
if ( refreshMaterial ){
    if ( materialProperties.needsLights ) {//光照信息相关
        //...
    }
    if ( fog && material.fog ) {//雾相关
        //...
    }
    //...
    if ( material.isSpriteMaterial ) {//精灵相关
	//..
    }
}
p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
return program;
function useProgram( program ) {//判断传入的WebGLProgram 对象是否存在于当前的渲染状态，如果不是，则添加到当前的渲染状态并返回true
    if ( currentProgram !== program ) {
        gl.useProgram( program );//glAPI
        currentProgram = program;
        return true;
    }
    return false;
}
```

## getProgram( material, scene, object )

```js
//program表示一个WebGLProgram(封装过的)
/** @WebGLProgram
             this.name = parameters.shaderName; 由material.type表示
             this.id = programIdCount ++;
             this.cacheKey = cacheKey;将一些信息转换为字符串 获取程序代码
             this.usedTimes = 1;
             this.program = program;由gl.createProgram()创建
             this.vertexShader = glVertexShader;由gl.createShader(gl.VERTEX_SHADER)创建
             this.fragmentShader = glFragmentShader;由gl.createShader(gl.FRAGMENT_SHADER)创建
**/
const materialProperties = properties.get( material );//初次为undefined
const materialProperties = properties.get( material );//初次为undefined
const lights = currentRenderState.state.lights;//灯光
const shadowsArray = currentRenderState.state.shadowsArray;//阴影
const lightsStateVersion = lights.state.version;//待解析
const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );//提取各种需要的属性
const programCacheKey = programCache.getProgramCacheKey( parameters );//将一些信息转换为字符串 获取程序代码
let programs = materialProperties.programs;//[一个WebGLProgram,下面会有详细解析]初次为undefined
materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;//环境(与环境贴图有关)
materialProperties.fog = scene.fog;//雾
materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );//环境贴图
if ( programs === undefined ) {//新的对象会进入(比如当scene.add(new Object3D))，已存在的program不会进入
    material.addEventListener( 'dispose', onMaterialDispose );
    programs = new Map();
    materialProperties.programs = programs;
}
let program = programs.get( programCacheKey );
if ( program !== undefined ) {
    //如果程序和灯光状态相同，则提前退出
    if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {
        updateCommonMaterialProperties( material, parameters );
        return program;
    }
} else {
    parameters.uniforms = programCache.getUniforms( material );//提取一些材质上的uniform
    material.onBuild( parameters, _this );//生命周期
    material.onBeforeCompile( parameters, _this );//生命周期
    program = programCache.acquireProgram( parameters, programCacheKey );//如果未创建program则会创建一个WebGLProgram
    programs.set( programCacheKey, program );//设置Map，这里设置了映射关系
    //materialProperties中的属性programs是一个Map,映射为programCacheKey==>program
    //materialProperties中的属性currentProgram保存的就是当前的program
    materialProperties.uniforms = parameters.uniforms;//为材质属性指定uniform
}
const uniforms = materialProperties.uniforms;
if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {
    uniforms.clippingPlanes = clipping.uniform;
}//待解析
updateCommonMaterialProperties( material, parameters );//用于提取属性返回给materialProperties
materialProperties.needsLights = materialNeedsLights( material );
materialProperties.lightsStateVersion = lightsStateVersion;
if ( materialProperties.needsLights ){
    uniforms.ambientLightColor.value = lights.state.ambient;
    ...//一堆属性
    //将区域灯光阴影信息添加到uniforms
}
    const progUniforms = program.getUniforms();//获取uniforms
    const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );//待解析
    materialProperties.currentProgram = program;//这里可以知道Current的值就是programs中键的值，都为一个WebGLProgram
    materialProperties.uniformsList = uniformsList;
    return program;


    //下面是一个流程中使用到的方法
    function updateCommonMaterialProperties( material, parameters ) {//用于提取属性返回给materialProperties
        const materialProperties = properties.get( material );
        materialProperties.outputEncoding = parameters.outputEncoding;
        materialProperties.instancing = parameters.instancing;
        materialProperties.skinning = parameters.skinning;
        materialProperties.morphTargets = parameters.morphTargets;
        materialProperties.morphNormals = parameters.morphNormals;
        materialProperties.numClippingPlanes = parameters.numClippingPlanes;
        materialProperties.numIntersection = parameters.numClipIntersection;
        materialProperties.vertexAlphas = parameters.vertexAlphas;
        materialProperties.vertexTangents = parameters.vertexTangents;
    }
```

## setMaterial( material, frontFaceCW )

```js
material.side === DoubleSide
    ? disable( gl.CULL_FACE )
: enable( gl.CULL_FACE );
let flipSided = ( material.side === BackSide );
if ( frontFaceCW ) flipSided = ! flipSided;
setFlipSided( flipSided );//通过设置缠绕方向来指定多边形是正面还是背
( material.blending === NormalBlending && material.transparent === false )//混合相关
    ? setBlending( NoBlending )
: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
depthBuffer.setFunc( material.depthFunc );//指定将输入像素深度与当前深度缓冲区值进行比较的函数。
depthBuffer.setTest( material.depthTest );//设置是否启用深度测试
depthBuffer.setMask( material.depthWrite );//设置是否启用写入深度缓冲。
colorBuffer.setMask( material.colorWrite );//方法设置在绘制或渲染到. WebGLFramebuffer,gl.colorMask(red, green, blue, alpha);
const stencilWrite = material.stencilWrite;//写入模板缓冲
stencilBuffer.setTest( stencilWrite );//设置是否启用模板测试
if ( stencilWrite ) {
    stencilBuffer.setMask( material.stencilWriteMask );//方法控制启用和禁用模板平面中各个位的正面和背面写入。
    stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );//方法设置了模板测试的前后功能和参考值。
    stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );//方法设置了正面和背面的模板测试操作。
}
setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );//启用或禁用多边形偏移填充
material.alphaToCoverage === true//启用或禁用多重采样
    ? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );
```
