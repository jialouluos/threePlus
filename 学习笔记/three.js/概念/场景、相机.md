# 场景、相机

一个Threejs的系统，不可或缺的有场景、相机、渲染器三大部分，他们之间的关系可以简单的这样来理解：场景就相当于一个虚拟的舞台，然后相机对着这个舞台，渲染器将他们组合，渲染到页面上，渲染就好比按下相机快门生成的那一帧图片。这帧图片会显示到网页上的canvas上。通过WebGLRenderer.render()方法，就可以实现连续渲染。每秒渲染的帧数跟电脑的配置有关。

## 场景

+   构造函数

    ```js
    //场景
    constructor() {
        super();//场景继承Object3D
        this.type = 'Scene';//设置type属性
        this.background = null;//该属性控制着场景的背景
        this.environment = null;//场景中所有物理材质的环境贴图。但是，无法覆盖分配给MeshStandardMaterial.envMap的现有纹理
        this.fog = null;//雾化
        this.overrideMaterial = null;//强制使用该材质渲染场景中的所有内容
        this.autoUpdate = true; // 检查每一帧场景及其对象是否需要矩阵更新
        if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {
            __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef
        }
    }
    //这里可以看出，Scene的各种配置都是以属性的方式，并非方法
    ```

+   background

    ```js
    //backgroud有两种设置方法，一种是直接设置某种颜色值，另一种是设置为一张背景图或者一个天空盒
    //设置某种颜色值
    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#ff0000");
    //设置一张背景图
    scene.background = new THREE.TextureLoader().load("./xx/xx/xx.jpg");
    //设置一个天空盒
    const path ="./xx/xx/";
    const format = ".jpg";
    //将六个面的贴图通过CubeTextureLoader()载入，顺序为[right,left,up,down,front,back]。
    const urls=["right","left","up","down","front","back"].map(part=>path+part+format);
    const Textures = new THREE.CubeTextureLoader().load(urls);
    scene.background = Textures;
    ```

+   environment

    ```js
    //environment场景中所有物理材质的环境贴图。但是，无法覆盖分配给MeshStandardMaterial.envMap的现有纹理。具体如何我们测试一遍就知道,经过我一下午的测试，发现了不少问题。
    //为scene.environment设置的值是一个envMap。可以通过两种方式得到envMap
    //第一种使用天空盒的方式来得到envMap
    const path ="./xx/xx/";
    const format = ".jpg";
    //将六个面的贴图通过CubeTextureLoader()载入，顺序为[right,left,up,down,front,back]。
    const urls=["right","left","up","down","front","back"].map(part=>path+part+format);
    const Textures = new THREE.CubeTextureLoader().load(urls);
    scene.environment = Textures;
    //第二种使用RGBELoader加载器,这里图片的格式为hdr
    new RGBELoader().setDataType(THREE.FloatType).load("../xx/xx/name.hdr",function(texture){
        texture.mapping = THREE.EquirectangularReflectionMapping;//采用这种方式生成的环境贴图需要将mapping设置为这个
        //EquirectangularReflectionMapping和EquirectangularRefractionMapping 用于等距矩形环境贴图。也称为经纬度地图，等距矩形纹理表示沿水平中心线的 360 度视图和沿垂直轴的 180 度视图，图像的顶部和底部边缘对应于一个映射的球体。
        scene.background = texture;//这里不是必须的
        scene.environment = texture;
    });
    //这里官方为envMap说明了为了确保物理上正确的渲染，您应该只添加由PMREMGenerator预处理的环境贴图。默认为空。当然其他的也行,比如我们这两种生成环境贴图的方式
    //如果环境贴图没有生效可以检查一下是否达到了环境贴图可视效果的条件，包括灯光，其他贴图的影响，某些参数的设置
    //总结一下，environment相当于给你的场景的所有物理材质(MeshStandardMaterial、MeshPhysicalMaterial)设置一个默认的环境贴图.
    ```

    | 条件（材质统一选择MeshStandardMaterial） | 天空盒创建环境贴图 | RGBELoader创建环境贴图 | PMREMGenerator预处理的环境贴图 |
    | ---------------------------------------- | ------------------ | ---------------------- | ------------------------------ |
    | 加载模型                                 | 成功               | 成功                   | 后续更新                       |
    | 自建网格                                 | 成功               | 成功                   | 后续更新                       |

+   fog	

    ```js
    //fog雾化
    //雾化提供了两种方式
    //1.FogExp2
    constructor( color, density = 0.00025 ) {//第一个参数是雾的颜色，第二个参数表示雾的密度的随距离的增长速度，该雾叫做指数雾
        this.name = '';
        this.color = new Color( color );
        this.density = density;//雾的密度随着距离指数增大
    }
    constructor( color, near = 1, far = 1000 ) {//该雾为线性雾，雾的密度随距离呈线性增长
        this.name = '';
        this.color = new Color( color );
        this.near = near;//雾化影响的最近距离（以相机位置为准）
        this.far = far;//雾化影响的最远距离（以相机位置为准）
    }
    //EG:
    scene.fog = new THREE.Fog("#ffff00",100,1000);
    scene.fog = new THREE.FogExp2(0xcc0000,0.001);
    ```

## 相机

+   相机主要说透视相机，相机继承Object3D,可以使用add方法，给相机对象添加一个子类，这样移动相机，它的子类会跟着一块移动，我们可以使用这个特性制作一些显示界面

+   构造函数

    ```js
    constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {继承Camera类，Camera继承Object3D类
        super();
        this.type = 'PerspectiveCamera';
        this.fov = fov;//视角
        this.zoom = 1;//相机的缩放系数。默认值为1。
        this.near = near;//最近可视距离
        this.far = far;//最远可视距离
        this.focus = 10;//用于立体视觉和景深效果的物距。除非使用StereoCamera，否则此参数不会影响投影矩阵。默认值为10。
        this.aspect = aspect;//视口长宽比
        this.view = null;//Frustum 窗口规范或 null。这是使用.setViewOffset方法设置的，并使用.clearViewOffset清除。
        this.filmGauge = 35;	// width of the film (default in millimeters)
        this.filmOffset = 0;	// horizontal film offset (same unit as gauge)
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const near = this.near;//构造函数中的near
        //一些计算方式
        let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
        let height = 2 * top;
        let width = this.aspect * height;
        let left = - 0.5 * width;
        const view = this.view;
        if ( this.view !== null && this.view.enabled ) {
            const fullWidth = view.fullWidth,
                  fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if ( skew !== 0 ) left += near * skew / this.getFilmWidth();
        //y
        this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );
        this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();
    }
    ```

    

    ```js
    //target与lookAt()都是调整相机的焦点
    //target
    const camera  =new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
    camera.target = new THREE.Vector3(0,0,0);
    //lookAt()
    camera.lookAt(new THREE.Vector3(0,0,0));
    camera.lookAt(0,0,0);//现在也可以这样写
    ```
    
