# 渲染器

​		渲染器分为3种渲染器，分别为WebGLRenderer、CSS2DRenderer、CSS3DRenderer三种渲染器

## WebGLRenderer

这是一个重点了解的渲染器，Three.js渲染器的渲染方法`.render()`，执行该方法就相当于执行WebGL 绘制方法`gl.drawArrays()`。
在WebGL中执行绘制方法`gl.drawArrays()`就会在Cnvas画布上绘制一帧图片，自然Threejs的渲染方法`.render()`同理，周期性执行 绘制方法`gl.drawArrays()`可以更新帧缓冲区数据，也就是更新Canvas画布显示图像，`.render()`方法同理可以实现一样的效果。

+   构造函数

    ```js
    function createCanvasElement() {
        const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
        canvas.style.display = 'block';
        return canvas;
    }
    function WebGLRenderer( parameters = {} ) {
    	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),//创建画布
    	_context = parameters.context !== undefined ? parameters.context : null,
    	_alpha = parameters.alpha !== undefined ? parameters.alpha : false, //boolean值表明canvas包含一个alpha缓冲区。 如果设置为false, 浏览器将认为canvas背景总是不透明的, 这样可以加速绘制透明的内容和图片.
    	_depth = parameters.depth !== undefined ? parameters.depth:true,//boolean值表明绘制缓冲区包含一个深度至少为16位的缓冲区。
    	_stencil = parameters.stencil !== undefined ? parameters.stencil:true,//表明绘制缓冲区包含一个深度至少为8位的模版缓冲区boolean值。
    	_antialias = parameters.antialias !== undefined ? parameters.antialias:false,//抗锯齿
    	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha:true,//表明排版引擎将假设绘制缓冲区包含预混合alpha通道的boolean值
    	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer:false,//如果这个值为true缓冲区将不会被清除，会保存下来，直到被清除或被使用者覆盖。
    	_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',//指示浏览器在运行WebGL上下文时使用相应的GPU电源配置。 可能值如下:"default":自动选择，默认值。"high-performance": 高性能模式。"low-power": 节能模式。
    	_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? 					parameters.failIfMajorPerformanceCaveat : false;//表明在一个系统性能低的环境是否创建该上下文的boolean值。
    	this.domElement = _canvas;//这里也就解释了为什么每次都需要将domElement属性添加给body作为子对象了
    	this.autoClear = true;//自动清除帧缓冲区
    	this.autoClearColor = true;//自动清除颜色缓冲区
    	this.autoClearDepth = true;//自动清除深度缓冲区
    	this.autoClearStencil = true;//自动清除模板缓冲区
     //基于物理的着色
    	this.outputEncoding = LinearEncoding;//用于纹理的编码属性。如果材质已使用纹理后更改编码类型，则需要将Material.needsUpdate设置为true以使材质重新编译。线性编码是默认值。除此以外的值仅对材质贴图、envMap(环境贴图) 和 emissiveMap(自发光贴图) 有效，此外THREE.GLTFLoader对所有颜色纹理都自定执行该操作，但是手动加载纹理需要
    //THREE.LinearEncoding//线性空间
    //THREE.sRGBEncoding//sRGB颜色空间
    //THREE.BasicDepthPacking
    //THREE.RGBADepthPacking
    	function getContext( contextNames, contextAttributes ) {
    	        for ( let i = 0; i < contextNames.length; i ++ ) {
    	            const contextName = contextNames[ i ];
    	            const context = _canvas.getContext( contextName, contextAttributes );
    	            if ( context !== null ) return context;
    	        }
    	        return null;
    	}
    	const contextAttributes = {
    		alpha: _alpha,
    		depth: _depth,
    		stencil: _stencil,
    		antialias: _antialias,
    		premultipliedAlpha: _premultipliedAlpha,
    		preserveDrawingBuffer: _preserveDrawingBuffer,
    		powerPreference: _powerPreference,
    		failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    	};
        const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];
        if ( _this.isWebGL1Renderer === true ) {//isWebGL1Renderer默认为true
            contextNames.shift();
        }
        _gl = getContext( contextNames, contextAttributes );//获取了一个webgl上下文，这里是二次封装的API 实际调用的是_canvas.getContext(contextName,contextAttributes)
        this.setClearColor = function () {
            background.setClearColor.apply( background, arguments );
        };
        this.clear = function ( color, depth, stencil ) {
            let bits = 0;
            if ( color === undefined || color ) bits |= 16384;
            if ( depth === undefined || depth ) bits |= 256;
            if ( stencil === undefined || stencil ) bits |= 1024;
            _gl.clear( bits );
        };
        this.clearColor = function () {//清除颜色缓冲区
            this.clear( true, false, false );
        };
        this.clearDepth = function () {//清除深度缓冲区
            this.clear( false, true, false );
        };
        this.clearStencil = function () {//清除模板缓冲区
            this.clear( false, false, true );
        };
    }
    
    ```

+   render==>25602

    ```js
    updateMatrixWorld( force ) {
        if ( this.matrixAutoUpdate ) this.updateMatrix();
        if ( this.matrixWorldNeedsUpdate || force ) {
            if ( this.parent === null ) {
                this.matrixWorld.copy( this.matrix );
            } else {
                this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        // update children
        const children = this.children;
        for ( let i = 0, l = children.length; i < l; i ++ ) {
            children[ i ].updateMatrixWorld( force );
        }
    }
    this.render = function ( scene, camera ) {
        if ( camera !== undefined && camera.isCamera !== true ) {
            console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
            return;
        }
        if ( _isContextLost === true ) return;
        // update scene graph
        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
        // update camera matrices and frustum
        if ( camera.parent === null ) camera.updateMatrixWorld();
        if ( xr.enabled === true && xr.isPresenting === true ) {
            if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );//XR相关相机矩阵的更新方法
            camera = xr.getCamera();
        }
        ......
        if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );//从这里开始找查
        if ( transmissiveObjects.length > 0 ) renderTransmissiveObjects( opaqueObjects, transmissiveObjects, scene, camera );
        if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );
        //
        ......
    };
    ```

+   renderObjects

    ```js
    function renderObjects( renderList, scene, camera ) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        if ( camera.isArrayCamera ) {
    				...
                    if ( object.layers.test( camera2.layers ) ) {
                        renderObject( object, scene, camera2, geometry, material, group );
                    }
        } else {
            		 ...
                renderObject( object, scene, camera, geometry, material, group );
            }
        }
    }
    function renderObject( object, scene, camera, geometry, material, group ) {
        object.onBeforeRender( _this, scene, camera, geometry, material, group );
        object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
        object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
        if ( object.isImmediateRenderObject ) {
            const program = setProgram( camera, scene, material, object );
            state.setMaterial( material );
            bindingStates.reset();
            renderObjectImmediate( object, program );
        } else {
            if ( material.transparent === true && material.side === DoubleSide ) {
                material.side = BackSide;
                material.needsUpdate = true;
                _this.renderBufferDirect( camera, scene, geometry, material, object, group );//从这里开始查找
                material.side = FrontSide;
                material.needsUpdate = true;
                _this.renderBufferDirect( camera, scene, geometry, material, object, group );
                material.side = DoubleSide;
            } else {
                _this.renderBufferDirect( camera, scene, geometry, material, object, group );
            }
        }
        object.onAfterRender( _this, scene, camera, geometry, material, group );
    }
    ```

+   renderBufferDirect

    ```js
    bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
    renderer = bufferRenderer
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    ...
    renderer.render(drawStart, drawCount);//从这里开始查找
    ...
    }
    
    ```

+   WebGLBufferRenderer

    ```js
    function WebGLBufferRenderer( gl, extensions, info, capabilities ) {
    	const isWebGL2 = capabilities.isWebGL2;
    	let mode;
    	function setMode( value ) {
    		mode = value;
    	}
    	function render( start, count ) {
    		gl.drawArrays( mode, start, count );//这里就是核心，调用了webgl的绘制方法drawArray
    
    		info.update( count, mode, 1 );
    
    	}
    
    	function renderInstances( start, count, primcount ) {
    
    		if ( primcount === 0 ) return;
    
    		let extension, methodName;
    
    		if ( isWebGL2 ) {
    
    			extension = gl;
    			methodName = 'drawArraysInstanced';
    
    		} else {
    
    			extension = extensions.get( 'ANGLE_instanced_arrays' );
    			methodName = 'drawArraysInstancedANGLE';
    
    			if ( extension === null ) {
    
    				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    				return;
    
    			}
    
    		}
    
    		extension[ methodName ]( mode, start, count, primcount );
    
    		info.update( count, mode, primcount );
    
    	}
    
    	//
    
    	this.setMode = setMode;
    	this.render = render;
    	this.renderInstances = renderInstances;
    
    }
    ```

    

## CSS2DRenderer

通过CSS2渲染器CSS2DRenderer不需要自己再进行坐标计算变换，该模块已经封装，简而言之就是通过CSS2渲染器CSS2DRenderer.js库很容易实现==把HTML元素作为模型的标签==。
threejs扩展库CSS2DRenderer.js提供了两个构造函数CSS2渲染器`THREE.CSS2DRenderer`、CSS2模型对象`THREE.CSS2DObject`。
CSS2渲染器`THREE.CSS2DRenderer`功能是渲染与threejs场景中网格模型绑定的HTML元素。
这里要特别说明一下，==CSS2DRenderer渲染的HTML是不可被遮挡的，也就是说他不守深度测试的影响，无论如何都会完整的显示==
同时CSS2DRenderer没有.setClearColor()方法

```js
//这里是给一个物体头上附加一个标签的小案例
const geometry = new THREE.BoxGeometry(5,5,5);
const material = new THREE.MeshBasicMaterial({color:"#ff0000"});
const mesh = new THREE.Mesh(geometry,material);
//创建一个div用于后续css2d渲染
const labeldiv = document.creatElemt("div");
div.innerHTML ="立方体"
div.style.padding ="10px";
//省略一系列css...
const label = new THREE.CSS2DObject(labeldiv);
label.position.copy(mesh.position);
label.position.y+=10;
scene.add(lable);
//创建css2d渲染器
const css2drenderer = new THREE.CSS2DRenderer();
css2drenderer.setSize(window.innerWidth,window.innerHeight);
//从这里开始
css2drenderer.domElement.style.position = 'absolute';
// 避免renderer.domElement影响HTMl标签定位，设置top为0px
css2drenderer.domElement.style.top = '0px';
css2drenderer.domElement.style.left = '0px';
//在这里结束，这里还有一种写法就是renderer.domElement.style.position = 'absolute';
//设置.pointerEvents=none，以免模型标签HTML元素遮挡鼠标选择场景模型
css2drenderer.domElement.style.pointerEvents = 'none';

document.body.appendChild(css2drenderer.domElement);
//特别的，我们需要在渲染的时候额外增加一条渲染2dcss的代码
//原：
render(){
    renderer.render(scene,camera);
   	requestAnimationFrame(render);
}
//现在:
render(){
    renderer.render(scene,camera);
    css2drenderer.render(scene,camera)
   	requestAnimationFrame(render);
}
```

## CSS3DRenderer

通过CSS3渲染器和模型可以把HTML元素像Threejs的网格模型`Mesh`或精灵模型`Sprite`一样去渲染。CSS3技术，简单的说就是对div等HTML元素进行旋转缩放平移。
CSS3DRenderer.js提供了三个构造函数CSS3渲染器`THREE.CSS3DRenderer`、CSS3模型对象`THREE.CSS3DObject`、CSS3精灵模型`THREE.CSS3DSprite`。
这里要特别说明一下，==CSS2DRenderer渲染的HTML是不可被遮挡的，也就是说他不守深度测试的影响，无论如何都会完整的显示==
同时CSS2DRenderer没有.setClearColor()方法

```js
//这里是给一个物体头上附加一个标签的小案例
const geometry = new THREE.BoxGeometry(5,5,5);
const material = new THREE.MeshBasicMaterial({color:"#ff0000"});
const mesh = new THREE.Mesh(geometry,material);
//创建一个div用于后续css2d渲染
const labeldiv = document.creatElemt("div");
div.innerHTML ="立方体"
div.style.padding ="10px";
//省略一系列css...
// 把div元素包装为CSS3DObject模型
// var obj = new THREE.CSS3DObject(tag);
// 把HTML元素包装为CSS3精灵模型CSS3DSprite
const obj = new THREE.CSS3DSprite( labeldiv );
label.position.copy(mesh.position);
label.position.y+=10;
scene.add(lable);
renderer.domElement.style.position = 'absolute';
const CSS3Renderer = new THREE.CSS3DRenderer();
CSS3Renderer.setSize(width, height); //设置渲染区域尺寸
document.body.appendChild(CSS3Renderer.domElement); //body元素中插入canvas对象
function render() {
    renderer.render(scene, camera); //执行渲染操作
    CSS3Renderer.render(scene, camera); //执行渲染操作
    requestAnimationFrame(render); //请求再次执行渲染函数render，渲染下一帧
}
```

