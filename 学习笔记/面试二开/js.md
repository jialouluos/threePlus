## 谈谈对js原型和原型链的理解
> 首先说一下js原型吧，在js中，每个对象都会有一个继承的父级对象，这个父级对象就是这个对象的原型。
这个父级对象会提供一些共享的方法和属性，当子对象通过构造函数来生成实例时，会自动为这个实例去分配原型对象，每一个构造函数上都会有一个prototype属性去指向这个对象的原型，每一个实例身上都会有一个隐性属性\__proto__去指向这个实例的构造函数的原型，当访问某个对象的属性时，如果对象本身没有，他会去父级对象上查找，

> 再说一下原型链，刚才也提到了当我们访问一个属性，如果这个实例他本身没有，那么会去找他的原型对象，如果他的原型对象身上存在这个属性，并且是首次找到，那么就会将这个值作为结果返回，如果不存在，那么又会去访问原型对象的原型对象，直到null，也就是说一个实例有构造他的原型对象，而他的原型对象又有构造他的原型对象，如此便构建出了一条链式的原型链

## 谈谈闭包
> 闭包他是一个函数，不是一种现象,他是一个可以访问其他函数作用域变量的一个函数，比如咱有一个函数，里面声明了一个变量，然后紧接着又创建一个函数，在这个函数里面如果去访问外层的变量，那么这时候他就是一个闭包，因为在他自己的函数作用域里面是没有这个变量的，他是在访问外层函数作用域的变量，这时候他就是一个闭包

## 谈谈const、var、let

> + 用var声明的变量存在变量提升，let、const不会
> + var和let可以只声明不赋值，const必须要给他初始值
> + const定义的变量不能够发生指向更改了,var和let可以
> + 用let、const声明的变量都存在暂时性死区，也就是在声明他之前都不能使用
> + var不存在块级作用域,let和const存在块级作用域,如果在块级作用域中用var声明一个变量，那么这个变量就会变成他父作用域下的变量。var 穿透了 if，for 和其它代码块。这是因为在早期的 JavaScript 中，块没有词法环境
> + var允许重复声明变量,let和const在同一作用域不允许重复声明变量

## 谈谈箭头函数

> 箭头函数没有自己的this，所以不能够对他使用new ，他也没有arguments，也没有yield命令不能够用作Generator函数

## 谈谈作用域

> 一种是静态作用域也就是我们说的词法作用域，他是以我们自己在写代码的时候将变量和作用域块写在哪决定的，另一种是动态作用域，他是以函数调用时所在的作用域去决定的，我们js采用的便是静态作用域
> 在js中作用域分为3种：全局作用域、块级作用域、函数作用域：
> + 对于全局作用域来说，最外层函数和在最外层函数外面定义的变量。所有未定义直接赋值的变量。所有window对象的属性都属于全局作用域，任何位置都能够访问得到他的属性或者函数
> + 对于块级作用域来说，代码块（用{}括起来的部分）中声明的变量，它只在这个代码块中有效,例如if、for
> + 对于函数作用域来说，他是声明在函数块内部变量，内部函数作用域可以访问外部函数作用域，但是外部函数作用域不能访问内部函数作用域

## 谈谈Symbol
> 